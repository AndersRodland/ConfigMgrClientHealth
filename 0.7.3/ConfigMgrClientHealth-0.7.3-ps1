<#
.SYNOPSIS
    ConfigMgr Client Health is a tool that validates and automatically fixes errors on Windows computers managed by Microsoft Configuration Manager.    
.EXAMPLE 
   .\ConfigMgrClientHealth.ps1 -Config .\Config.Xml
.EXAMPLE 
    \\sccm.lab.net\ClientHealth$\ConfigMgrClientHealth.ps1 -Config \\sccm.lab.net\ClientHealth$\Config.Xml
.PARAMETER Config
    A single parameter specifying the path to the configuration XML file.
.DESCRIPTION
    ConfigMgr Client Health detects and fixes following errors:
        * ConfigMgr client is not installed.
        * ConfigMgr client is assigned the correct site code.
        * ConfigMgr client is upgraded to current version if not at specified minimum version.
        * ConfigMgr client not able to forward state messages to management point.
        * ConfigMgr client stuck in provisioning mode.
        * ConfigMgr client maximum log file size.
        * ConfigMgr client cache size.
        * Corrupt WMI.
        * Services for ConfigMgr client is not running or disabled.
        * Other services can be specified to start and run and specific state.
        * Hardware inventory is running at correct schedule
        * Group Policy failes to update registry.pol
        * Pending reboot blocking updates from installing
        * ConfigMgr Client Update Handler is working correctly with registry.pol
        * Windows Update Agent not working correctly, causing client not to receive patches.
        * Windows Update Agent missing patches that fixes known bugs.
.NOTES 
    You should run this with at least local administrator rights. It is recommended to run this script under the SYSTEM context.
    
    DO NOT GIVE USERS WRITE ACCESS TO THIS FILE. LOCK IT DOWN !
    
    Author: Anders Rødland
    Blog: https://www.andersrodland.com
    Twitter: @AndersRodland
.LINK
    Full documentation: https://www.andersrodland.com/configmgr-client-health/
#> 

<# TESTING ONLY
$config = "\\cm01.rodland.lab\clienthealth$\config.xml"
$config = "D:\OneDrive\Powershell\SCCM\Client-Health\Development\0.7.3\config.xml"
#>

[CmdletBinding(SupportsShouldProcess=$true, ConfirmImpact="Medium")]
param(
    [Parameter(Mandatory=$True, HelpMessage='Path to XML Configuration File')]
    [ValidateScript({Test-Path -Path $_ -PathType Leaf})]
    [ValidatePattern('.xml$')]
    [string]$Config
)

Begin {
    # ConfigMgr Client Health Version
    $Version = '0.7.3'
    $PowerShellVersion = [int]$PSVersionTable.PSVersion.Major

    Write-Verbose "Script version: $Version"
    Write-Verbose "PowerShell version: $PowerShellVersion"
    
    # Read configuration from XML file
    if (Test-Path $Config) {
        Try {
            $Xml = [xml](Get-Content -Path $Config)
        } Catch {
            $ErrorMessage = $_.Exception.Message
            $text = "Error, could not read $Config. Check file location and share/ntfs permissions. Is XML config file damaged?"
            $text += "`nError message: $ErrorMessage"
            Write-Error $text
            Exit 1
        }
    }
    else {
        $text = "Error, could not access $Config. Check file location and share/ntfs permissions. Did you misspell the name?"
        Write-Error $text
        Exit 1
    }

    # Import Modules
    # Import BitsTransfer Module (Does not work on PowerShell 6.0 Beta 8, disable check if module failes to import.)    
    $BitsCheckEnabled = $false
    try {
        Import-Module BitsTransfer -ErrorAction stop
        $BitsCheckEnabled = $true
    }
    catch {
        $BitsCheckEnabled = $false
    }

    #region functions
    Function Get-DateTime {
        $format = (Get-XMLConfigLoggingTimeFormat).ToLower()
        
        if ($format -like "utc") {
            # UTC Time
            $obj = ([DateTime]::UtcNow).ToString("yyyy-MM-dd HH:mm:ss")
        }
        else {
            # ClientLocal
            $obj = (Get-Date -Format "yyyy-MM-dd HH:mm:ss")
        }
        Write-Output $obj
    }

    # Converts a DateTime object to UTC time.
    Function Get-UTCTime {
        param([Parameter(Mandatory=$true)][DateTime]$DateTime)
        $obj = $DateTime.ToUniversalTime()
        Write-Output $obj
    }

    Function Get-LogFileName {
        #$OS = Get-WmiObject -class Win32_OperatingSystem
        $OSName = Get-OperatingSystem
        $logshare = Get-XMLConfigLoggingShare
        #$obj = "$logshare\$OSName\$env:computername.log"
        $obj = "$logshare\$env:computername.log"
        Write-Output $obj
    }

    Function Test-LocalLogging {
        $clientpath = Get-LocalFilesPath
        if ((Test-Path -Path $clientpath) -eq $False) {
            New-Item -Path $clientpath -ItemType Directory -Force | Out-Null
        }
    }

    Function Out-LogFile {
        Param([Parameter(Mandatory=$false)][xml]$Xml, $Text, $Mode)
        
        if ($Mode -like "Local") {
            Test-LocalLogging
            $clientpath = Get-LocalFilesPath
            $Logfile = "$clientpath\ClientHealth.log"
        }
        else { $Logfile = Get-LogFileName }

        if ($mode -like "ClientInstall" ) { $text = "ConfigMgr Client installation failed. Agent not detected 10 minutes after triggering installation." }
        
        $obj = '[' +(Get-DateTime) +'] '+$text
        $obj | Out-File -Encoding utf8 -Append $logFile
    }

    Function Get-OperatingSystem {
        $OS = Get-WmiObject -class Win32_OperatingSystem
        
        # Handles different OS languages
        $OSArchitecture = ($OS.OSArchitecture -replace ('([^0-9])(\.*)', '')) + '-Bit'
        switch -Wildcard ($OS.Caption) {
            "*Embedded*" {$OSName = "Windows 7 " + $OSArchitecture}
            "*Windows 7*" {$OSName = "Windows 7 " + $OSArchitecture}
            "*Windows 8.1*" {$OSName = "Windows 8.1 " + $OSArchitecture}
            "*Windows 10*" {$OSName = "Windows 10 " + $OSArchitecture}
            "*Server 2008*" {
                if ($OS.Caption -like "*R2*") {
                    $OSName = "Windows Server 2008 R2 " + $OSArchitecture
                }
                else {
                    $OSName = "Windows Server 2008 " + $OSArchitecture
                }
            }
            "*Server 2012*" {
                if ($OS.Caption -like "*R2*") {
                    $OSName = "Windows Server 2012 R2 " + $OSArchitecture
                }
                else {
                    $OSName = "Windows Server 2012 " + $OSArchitecture
                }
            }
            "*Server 2016*" {
                $OSName = "Windows Server 2016 " + $OSArchitecture
            }
        }
        Write-Output $OSName
    }

    Function Get-MissingUpdates {
        $UpdateShare = Get-XMLConfigUpdatesShare
        $OSName = Get-OperatingSystem

        $build = $null
        if ($OSName -like "*Windows 10*") {
            $build = Get-WmiObject Win32_OperatingSystem | Select-Object -ExpandProperty BuildNumber
            switch ($build) {
                10586 {$OSName = $OSName + " 1511"}
                14393 {$OSName = $OSName + " 1607"}
                15063 {$OSName = $OSName + " 1703"}
                16299 {$OSName = $OSName + " 1709"}
                default {$OSName = $OSName + " Insider Preview"}
            }
        }

        $Updates = $UpdateShare + "\" + $OSName + "\"
        $obj = New-Object PSObject @{}
        If ((Test-Path $Updates) -eq $true) {
            $regex = "\b(?!(KB)+(\d+)\b)\w+"
            $hotfixes = (Get-ChildItem $Updates | Select-Object -ExpandProperty Name)
            $installedUpdates = Get-Hotfix | Select-Object -ExpandProperty HotFixID

            foreach ($hotfix in $hotfixes) {
                $kb = $hotfix -replace $regex -replace "\." -replace "-"
                if ($installedUpdates -like $kb) {}
                else {
                    $obj.Add('Hotfix', $hotfix)
                }
            }
        }
        Write-Output $obj
    }

    Function Get-RegistryValue {
        param (
            [parameter(Mandatory=$true)][ValidateNotNullOrEmpty()]$Path,
            [parameter(Mandatory=$true)][ValidateNotNullOrEmpty()]$Name
        )

        try {
            $obj = Get-ItemProperty -Path $Path | Select-Object -ExpandProperty $Name -ErrorAction Stop | Out-Null
        } catch {
            $obj = $false
        } finally {
            Write-Output $obj
        }
    }

    Function Get-Sitecode {
        try {
            $obj = $([WmiClass]"ROOT\ccm:SMS_Client").getassignedsite() | Select-Object -Expandproperty sSiteCode
        } catch {
            $obj = '...'
        } finally {
            Write-Output $obj
        }
    }

    Function Get-ClientVersion {
        try { $obj = (Get-WmiObject -Namespace root/ccm SMS_Client).ClientVersion }
        catch { $obj = $false }
        finally { Write-Output $obj }
    }

    Function Get-ClientCache {
        try {
            $obj = (Get-WmiObject -Namespace "ROOT\CCM\SoftMgmtAgent" -Class CacheConfig -ErrorAction SilentlyContinue).Size
        } catch {
            #$obj = $false
            $obj = 0
        } finally {
            if ($obj -eq $null) {
                $obj = 0
            }
            Write-Output $obj
        }
    }

    Function Get-ClientMaxLogSize {
        try {
            $obj = [Math]::Round(((Get-ItemProperty -Path 'HKLM:\SOFTWARE\Microsoft\CCM\Logging\@Global').LogMaxSize) / 1000)
        } catch {
            $obj = 0
        } finally {
            Write-Output $obj
        }
    }
    

    Function Get-ClientMaxLogHistory {
        try {
            $obj = (Get-ItemProperty -Path 'HKLM:\SOFTWARE\Microsoft\CCM\Logging\@Global').LogMaxHistory
        } catch {
            $obj = 0
        } finally {
            Write-Output $obj
        }
    }


    Function Get-Domain {
        try {
            $obj = (Get-WmiObject Win32_ComputerSystem).Domain
        } catch {
            $obj = $false
        } finally {
            Write-Output $obj
        }
    }

    Function Get-CCMLogDirectory {
        $obj = (Get-ItemProperty -Path 'HKLM:\SOFTWARE\Microsoft\CCM\Logging\@Global').LogDirectory
        Write-Output $obj
    }

    Function Test-CcmSQLCELog {
        $logdir = Get-CCMLogDirectory
        $ccmdir = $logdir.replace("\Logs", "")
        $logFile = "$logdir\CcmSQLCE.log"
        $logLevel = (Get-ItemProperty -Path 'HKLM:\SOFTWARE\Microsoft\CCM\Logging\@Global').logLevel

        if ( (Test-Path -Path $logFile) -and ($logLevel -ne 0) ) {
            # Not in debug mode, and CcmSQLCE.log exists. This could be bad.
            $LastWriteTime = (Get-ChildItem $logFile).LastWriteTime
            $CreationTime = (Get-ChildItem $logFile).CreationTime
            $FileDate = Get-Date($LastWriteTime)
            $FileCreated = Get-Date($CreationTime)

            $now = Get-Date
            if ( (($now - $FileDate).Days -lt 7) -and ((($now - $FileCreated).Days) -gt 7) ) {
                $text = "CM client not in debug mode, and CcmSQLCE.log exists. This is very bad. Cleaning up local SDF files and reinstalling CM client"
                Write-Host $text -ForegroundColor Red
                # Delete *.SDF Files
                $Service = Get-Service -Name ccmexec
                $Service.Stop()
                
                $seconds = 0
                Do {
                    Start-Sleep -Seconds 1
                    $seconds++
                } while ( ($Service.Status -ne "Stopped") -and ($seconds -le 60) )
    
                # Do another test to make sure CcmExec service really is stopped
                if ($Service.Status -ne "Stopped") {
                    Stop-Service -Name ccmexec -Force
                }
                
                Write-Verbose "Waiting 10 seconds to allow file locking issues to clear up"
                Start-Sleep -seconds 10
    
                try {
                    $files = Get-ChildItem "$ccmdir\*.sdf"
                    $files | Remove-Item -Force | Out-Null
                    Remove-Item -Path $logFile -Force | Out-Null
                }
                catch {
                    Write-Verbose "Obviously that wasn't enough time"
                    Start-Sleep -Seconds 30
                    # We try again
                    $files = Get-ChildItem "$ccmdir\*.sdf"
                    $files | Remove-Item -Force | Out-Null
                    Remove-Item -Path $logFile -Force | Out-Null
                }
                
                $obj = $true
            }

            else {
                # CcmSQLCE.log has not been updated for two days. We are good for now.
                $obj = $false
            }
        }
        else {
            # we are good
            $obj = $false
        }
        Write-Output $obj

    }

    function Test-CCMCertificateError {
        # More checks to come
        $logdir = Get-CCMLogDirectory
        $logFile1 = "$logdir\ClientIDManagerStartup.log"
        $error1 = 'Failed to find the certificate in the store'
        $error2 = '[RegTask] - Server rejected registration 3'
        $content = Get-Content -Path $logFile1

        $ok = $true

        if ($content -match $error1) {
            $ok = $false
            $text = 'ConfigMgr Client Certificate: Error failed to find the certificate in store. Attempting fix.'
            Write-Warning $text
            Stop-Service -Name ccmexec -Force
            # Name is persistant across systems.
            $cert = 'C:\ProgramData\Microsoft\Crypto\RSA\MachineKeys\19c5cf9c7b5dc9de3e548adb70398402_50e417e0-e461-474b-96e2-077b80325612'
            # CCM creates new certificate when missing.
            Remove-Item -Path $cert -Force -ErrorAction SilentlyContinue | Out-Null
            # Remove the error from the logfile to avoid double remediations based on false positives
            $newContent = $content | Select-String -pattern $Error1 -notmatch
            Out-File -FilePath $logfile -InputObject $newContent -Encoding utf8 -Force
            Start-Service -Name ccmexec
            #Remove-Item $logFile -Force -ErrorAction SilentlyContinue | Out-Null
            
            # Update log object
            $log.Certificate = $error1
        }

        #$content = Get-Content -Path $logFile2
        if ($content -match $error2) {
            $ok = $false
            $text = 'ConfigMgr Client Certificate: Error! Server rejected client registration. Client Certificate not valid. No auto-remediation.'
            Write-Error $text
            $log.Certificate = $error2
        }

        if ($ok = $true) {
            $text = 'ConfigMgr Client Certificate: OK'
            Write-Output $text
            $log.Certificate = 'OK'
        }
    }


    Function Test-BITS {
        Param([Parameter(Mandatory=$true)]$Log)
        
        if ($BitsCheckEnabled -eq $true) {
            $Errors = Get-BitsTransfer -AllUsers | Where-Object { ($_.JobState -like "TransientError") -or ($_.JobState -like "Transient_Error") -or ($_.JobState -like "Error") }
            
            if ($Errors -ne $null) {
                $fix = (Get-XMLConfigBITSCheckFix).ToLower()
                
                if ($fix -eq "true") {
                    $text = "BITS: Error. Remediating"
                    $Errors | Remove-BitsTransfer
                    $log.BITS = 'Remediated'
                    $obj = $true
                }
                else {
                    $text = "BITS: Error. Monitor only"
                    $log.BITS = 'Error'
                    $obj = $false
                }
            }
            
            else {
                $text = "BITS: OK"
                $log.BITS = 'OK'
                $Obj = $false
            }
                    
        }
        else {
            $text = "BITS: PS Module BitsTransfer missing. Skipping check"
            $log.BITS = "PS Module BitsTransfer missing"
            $obj = $false
        }

        Write-Host $text
        Write-Output $Obj

    }

    Function New-ClientInstalledReason {
        Param(
            [Parameter(Mandatory=$true)]$Message,
            [Parameter(Mandatory=$true)]$Log
            )

        if ($log.ClientInstalledReason -eq $null) {
            $log.ClientInstalledReason = $Message
        }
        else {
            $log.ClientInstalledReason += " $Message"
        }
    }


    function Get-PendingReboot {
        $result = @{
            CBSRebootPending =$false
            WindowsUpdateRebootRequired = $false
            FileRenamePending = $false
            SCCMRebootPending = $false
        }

        #Check CBS Registry
        $key = Get-ChildItem "HKLM:Software\Microsoft\Windows\CurrentVersion\Component Based Servicing\RebootPending" -ErrorAction SilentlyContinue
        if ($null -ne $key) 
        {
            $result.CBSRebootPending = $true
        }
    
        #Check Windows Update
        $key = Get-Item 'HKLM:SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Auto Update\RebootRequired' -ErrorAction SilentlyContinue
        if ($null -ne $key) 
        {
            $result.WindowsUpdateRebootRequired = $true
        }

        #Check PendingFileRenameOperations
        $prop = Get-ItemProperty 'HKLM:SYSTEM\CurrentControlSet\Control\Session Manager' -Name PendingFileRenameOperations -ErrorAction SilentlyContinue
        if ($null -ne $prop) 
        {
            #PendingFileRenameOperations is not *must* to reboot?
            #$result.FileRenamePending = $true
        }
        
        try 
        { 
            $util = [wmiclass]'\\.\root\ccm\clientsdk:CCM_ClientUtilities'
            $status = $util.DetermineIfRebootPending()
            if(($null -ne $status) -and $status.RebootPending){
                $result.SCCMRebootPending = $true
            }
        }catch{}

        #Return Reboot required
        if ($result.ContainsValue($true)) {
            #$text = 'Pending Reboot: YES'
            $obj = $true
            $log.PendingReboot = 'Pending Reboot'
        }
        else {
            $obj = $false
            $log.PendingReboot = 'OK'
        }
        Write-Output $obj
    }

    Function Get-ProvisioningMode {
        $registryPath = 'HKLM:\SOFTWARE\Microsoft\CCM\CcmExec'
        $provisioningMode = (Get-ItemProperty -Path $registryPath).ProvisioningMode

        if ($provisioningMode -eq 'true') {
            $obj = $true
        }
        else {
            $obj = $false
        }
        Write-Output $obj
    }

    Function Get-OSDiskFreeSpace {
        $driveC = Get-WmiObject -Class Win32_LogicalDisk | Where-Object {$_.DeviceID -eq 'C:'} | Select-Object FreeSpace, Size
        $freeSpace = (($driveC.FreeSpace / $driveC.Size) * 100)
        Write-Output ([math]::Round($freeSpace,2))
    }

    Function Get-Computername {
        $obj = (Get-WmiObject Win32_ComputerSystem).Name
        Write-Output $obj
    }

    Function Get-LastBootTime {
        $wmi = Get-WmiObject Win32_OperatingSystem
        $obj = $wmi.ConvertToDateTime($wmi.LastBootUpTime)
        Write-Output $obj
    }

    Function Get-LastInstalledPatches {
        Param([Parameter(Mandatory=$true)]$Log)
        # Reading date from Windows Update COM object.
        $Session = New-Object -ComObject Microsoft.Update.Session
        $Searcher = $Session.CreateUpdateSearcher()
        $HistoryCount = $Searcher.GetTotalHistoryCount()
        
        $OS = Get-OperatingSystem
        Switch -Wildcard ($OS) {
            "*Windows 7*" { $Date = $Searcher.QueryHistory(0,$HistoryCount) | Where-Object {$_.ClientApplicationID -eq 'AutomaticUpdates'} | Select-Object -ExpandProperty Date | Measure-Latest }
            "*Windows 8*" { $Date = $Searcher.QueryHistory(0,$HistoryCount) | Where-Object ClientApplicationID -eq AutomaticUpdatesWuApp | Select-Object -ExpandProperty Date | Measure-Latest }
            "*Windows 10*" { $Date = $Searcher.QueryHistory(0,$HistoryCount) | Where-Object {$_.ClientApplicationID -eq 'UpdateOrchestrator'} | Select-Object -ExpandProperty Date | Measure-Latest }
            "*Server 2008*" { $Date = $Searcher.QueryHistory(0,$HistoryCount) | Where-Object {$_.ClientApplicationID -eq 'AutomaticUpdates'} | Select-Object -ExpandProperty Date | Measure-Latest }
            "*Server 2012*" { $Date = $Searcher.QueryHistory(0,$HistoryCount) | Where-Object ClientApplicationID -eq AutomaticUpdatesWuApp | Select-Object -ExpandProperty Date | Measure-Latest }
            "*Server 2016*" { $Date = $Searcher.QueryHistory(0,$HistoryCount) | Where-Object {$_.ClientApplicationID -eq 'UpdateOrchestrator'} | Select-Object -ExpandProperty Date | Measure-Latest }
        }

        # Reading date from PowerShell Get-Hotfix
        #$now = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
        #$Hotfix = Get-Hotfix | Where-Object {$_.InstalledOn -le $now} | Select-Object -ExpandProperty InstalledOn -ErrorAction SilentlyContinue
        
        #$Hotfix = Get-Hotfix | Select-Object -ExpandProperty InstalledOn -ErrorAction SilentlyContinue
        
        $Hotfix = Get-Hotfix | Select-Object @{l="InstalledOn";e={[DateTime]::Parse($_.psbase.properties["installedon"].value,$([System.Globalization.CultureInfo]::GetCultureInfo("en-US")))}}
        $Hotfix = $Hotfix | Select-Object -ExpandProperty InstalledOn

        $Date2 = $null
        
        if ($null -ne $hotfix) {
            $Date2 = Get-Date($hotfix | Measure-Latest) -ErrorAction SilentlyContinue
        }

        if (($Date -ge $Date2) -and ($null -ne $Date)) {
            $Log.OSUpdates = Get-SmallDateTime -Date $Date
        }
        elseif (($Date2 -gt $Date) -and ($null -ne $Date2)) {
            $Log.OSUpdates = Get-SmallDateTime -Date $Date2
        }
    }

    function Measure-Latest {
        BEGIN { $latest = $null }
        PROCESS {
                if (($null -ne $_) -and (($null -eq $latest) -or ($_ -gt $latest))) {
                    $latest = $_ 
                }
        }
        END { $latest }
    }

    Function Test-LogFileHistory {
        Param([Parameter(Mandatory=$true)]$Logfile)
        $startString = '<--- ConfigMgr Client Health Check starting --->'
        #$stopString = '<--- ConfigMgr Client Health Check finished --->'
        
        $content = ''
        
        # Handle the network share log file
        if (Test-Path $logfile -ErrorAction SilentlyContinue)  {
            $content = Get-Content($logfile)
        }
        $maxHistory = Get-XMLConfigLoggingMaxHistory
        $startCount = [regex]::matches($content,$startString).count
        #$stopCount = [regex]::matches($content,$stopString).count
        
        # Delete logfile if more start and stop entries than max history
        if ($startCount -ge $maxHistory) {
            if ((Test-Path -Path $logfile -ErrorAction SilentlyContinue) -eq $true) {
                Remove-Item $logfile -Force
            }
        }
    }

    Function Test-DNSConfiguration {
        Param([Parameter(Mandatory=$true)]$Log)
        #$dnsdomain = (Get-WmiObject Win32_NetworkAdapterConfiguration -filter "ipenabled = 'true'").DNSDomain
        $fqdn = [System.Net.Dns]::GetHostEntry([string]"localhost").HostName
        $localIPs = Get-WmiObject Win32_NetworkAdapterConfiguration | Where-Object {$_.IPEnabled -Match "True"} |  Select-Object -ExpandProperty IPAddress
        $dnscheck = [System.Net.DNS]::GetHostByName($fqdn)


        $OSName = Get-OperatingSystem
        if (($OSName -notlike "*Windows 7*") -or ($OSName -notlike "*Server 2008*")) {
            # This method is supported on Windows 8 / Server 2012 and higher. More acurate than using .NET object method
            try {
                $dnsServers = Get-DnsClientServerAddress | Where-Object {$_.AddressFamily -eq 2} | Select-Object –ExpandProperty ServerAddresses
                $dnsAddressList = Resolve-DnsName -Name $fqdn -Server ($dnsServers | Select-Object -First 1) -Type A -DnsOnly | Select-Object -ExpandProperty IPAddress
            }
            catch {
                # Fallback to depreciated method
                $dnsAddressList = $dnscheck.AddressList | Select-Object -ExpandProperty IPAddressToString
                $dnsAddressList = $dnsAddressList -replace("%(.*)", "")
            }
        }

        else {
            # This method cannot guarantee to only resolve against DNS sever. Local cache can be used in some circumstances.
            # For Windows 7 only
            
            #$dnscheck = [System.Net.DNS]::GetHostEntry($fqdn)
            $dnsAddressList = $dnscheck.AddressList | Select-Object -ExpandProperty IPAddressToString
            $dnsAddressList = $dnsAddressList -replace("%(.*)", "")
        }

        $dnsFail = ''
        $logFail = ''

        Write-Verbose 'Verify that local machines FQDN matches DNS'
        if ($dnscheck.HostName -like $fqdn) {
            $obj = $true
            Write-Verbose 'Checking if one local IP matches on IP from DNS'
            Write-Verbose 'Loop through each IP address published in DNS'
            foreach ($dnsIP in $dnsAddressList) {
                #Write-Host "Testing if IP address: $dnsIP published in DNS exist in local IP configuration."
                ##if ($dnsIP -notin $localIPs) { ## Requires PowerShell 3. Works fine :(
                if ($localIPs -notcontains $dnsIP) {
                   $dnsFail += "IP '$dnsIP' in DNS record do not exist locally`n"
                   $logFail += "$dnsIP "
                   $obj = $false
                }
            }
        }
        else {
            $hn = $dnscheck.HostName
            $dnsFail = 'DNS name: ' +$hn + ' local fqdn: ' +$fqdn + ' DNS IPs: ' +$dnsAddressList + ' Local IPs: ' + $localIPs
            $obj = $false
            Write-Host $dnsFail
        }

        switch ($obj) {
            $false {
                $fix = (Get-XMLConfigDNSFix).ToLower()
                if ($fix -eq "true") {
                    $text = 'DNS Check: FAILED. IP address published in DNS do not match IP address on local machine. Trying to resolve by registerting with DNS server'
                    if ($PowerShellVersion -ge 4) {
                        Register-DnsClient | out-null
                    }
                    else {
                        ipconfig /registerdns | out-null
                    }
                    Write-Host $text
                    $log.DNS = $logFail
                    Out-LogFile -Xml $xml -Text $text
                    Out-LogFile -Xml $xml -Text $dnsFail
                }
                else {
                    $text = 'DNS Check: FAILED. IP address published in DNS do not match IP address on local machine. Monitor mode only, no remediation'
                    $log.DNS = $logFail
                    Out-LogFile -Xml $xml -Text $text
                    Write-Host $text
                }
                
            }
            $true {
                $text = 'DNS Check: OK'
                Write-Output $text
                $log.DNS = 'OK'
            }
        }
        #Write-Output $obj
    }

    # Function to test that 'HKU:\S-1-5-18\Software\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders\' is set to '%USERPROFILE%\AppData\Roaming'. CCMSETUP will fail if not.
    # Reference: https://www.systemcenterdudes.com/could-not-access-network-location-appdata-ccmsetup-log/
    Function Test-CCMSetup1 {
        New-PSDrive -PSProvider Registry -Name HKU -Root HKEY_USERS -ErrorAction SilentlyContinue | Out-Null
        $correctValue = '%USERPROFILE%\AppData\Roaming'
        $currentValue = (Get-Item 'HKU:\S-1-5-18\Software\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders\').GetValue('AppData', $null, 'DoNotExpandEnvironmentNames')

       # Only fix if the value is wrong
       if ($currentValue -ne $correctValue) {
            Set-ItemProperty -Path  'HKU:\S-1-5-18\Software\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders\' -Name 'AppData' -Value $correctValue
        }
    }

    Function Test-Update {
        Param([Parameter(Mandatory=$true)]$Log)
        Write-Verbose 'Only run update check if enabled'
        
        $UpdatesEnabled = Get-XMLConfigUpdatesEnable
        if ($UpdatesEnabled -like 'True') {
        #if (($Xml.Configuration.Option | Where-Object {$_.Name -like 'Updates'} | Select-Object -ExpandProperty 'Enable') -like 'True') {
            
            $UpdateShare = Get-XMLConfigUpdatesShare
            #$UpdateShare = $Xml.Configuration.Option | Where-Object {$_.Name -like 'Updates'} | Select-Object -ExpandProperty 'Share'
            Write-Verbose "Validating required updates is installed on the client. Required updates will be installed if missing on client."
            #$OS = Get-WmiObject -class Win32_OperatingSystem
            $OSName = Get-OperatingSystem

            $build = $null
            if ($OSName -like "*Windows 10*") {
                $build = Get-WmiObject Win32_OperatingSystem | Select-Object -ExpandProperty BuildNumber
                switch ($build) {
                    10586 {$OSName = $OSName + " 1511"}
                    14393 {$OSName = $OSName + " 1607"}
                    15063 {$OSName = $OSName + " 1703"}
                    16299 {$OSName = $OSName + " 1709"}
                    default {$OSName = $OSName + " Insider Preview"}
                }
            }

            $Updates = $UpdateShare + "\" + $OSName + "\"
            If ((Test-Path $Updates) -eq $true) {
                $regex = "\b(?!(KB)+(\d+)\b)\w+"
                $hotfixes = (Get-ChildItem $Updates | Select-Object -ExpandProperty Name)
                $installedUpdates = Get-Hotfix | Select-Object -ExpandProperty HotFixID
                $count = $hotfixes.count

                if (($count -eq 0) -or ($count -eq $null)) {
                    $text = 'Updates: No mandatory updates to install.'
                    Write-Output $text
                    $log.Updates = 'OK'
                }
                else {
                    $logEntry = $null
                    
                    foreach ($hotfix in $hotfixes) {
                        $kb = $hotfix -replace $regex -replace "\." -replace "-"
                        if ($installedUpdates -like $kb) {
                            $text = "Update $hotfix" + ": OK"
                            Write-Output $text
                        }
                        else {
                            if ($null -eq $logEntry) {
                                $logEntry = $kb
                            }
                            else {
                                $logEntry += ", $kb"
                            }

                            $fix = (Get-XMLConfigUpdatesFix).ToLower()
                            if ($fix -eq "true") {
                                $kbfullpath = $updates + "$hotfix"
                                $text = "Update $hotfix" + ": Missing. Installing now..."
                                Write-Warning $text

                                $clientpath = Get-LocalFilesPath
                    
                                If ((Test-Path "$clientpath\Temp") -eq $false) {
                                    New-Item -Path "$clientpath\Temp" -ItemType Directory | Out-Null
                                }
                    
                                Copy-Item -Path $kbfullpath -Destination "$clientpath\temp"
                                $install = "$clientpath\Temp\" +$hotfix
                    
                                wusa.exe $install /quiet /norestart
                                While (Get-Process wusa -ErrorAction SilentlyContinue) {
                                    Start-Sleep -Seconds 2
                                }
                                Remove-Item $install -Force -Recurse
                            }
                            else {
                                $text = "Update $hotfix" + ": Missing. Monitor mode only, no remediation."
                                Write-Warning $text
                            }
                        }

                        if ($null -eq $logEntry) {
                            $log.Updates = 'OK'
                        }
                        else {
                            $log.Updates = $logEntry
                        }
                    }
                }
            }
        }
    }

    Function Test-ConfigMgrClient {
        Param([Parameter(Mandatory=$true)]$Log)

        # Check if the SCCM Agent is installed or not.
        # If installed, perform tests to decide if reinstall is needed or not.
        if (Get-Service -Name ccmexec -ErrorAction SilentlyContinue) {
            $text = "Configuration Manager Client is installed"
            Write-Host $text

            # Lets not reinstall client unless tests tells us to.
            $Reinstall = $false

            $testLocalDB = (Get-XMLConfigCcmSQLCELog).ToLower()

            # Only test CM client local DB if this check is enabled
            if ($testLocalDB -like "enable") {
                Write-Host "Testing CcmSQLCELog"
                $LocalDB = Test-CcmSQLCELog
                if ($LocalDB -eq $true) {
                    # LocalDB is messed up
                    New-ClientInstalledReason -Log $Log -Message "ConfigMgr Client database corrupt."
                    Write-Host "ConfigMgr Client database corrupt. Reinstalling..."
                    $Reinstall = $true
                }
            }

            $CCMService = Get-Service -Name ccmexec -ErrorAction SilentlyContinue

            # Reinstall if we are unable to start the CM client
            if (($CCMService.Status -eq "Stopped") -and ($LocalDB -eq $false)) {
                try {
                    Write-Host "ConfigMgr Agent not running. Attempting to start it."
                    if ($CCMService.StartType -ne "Automatic") {
                        $text = "Configuring service CcmExec StartupType to: Automatic (Delayed Start)..."
                        Write-Output $text
                        Set-Service -Name CcmExec -StartupType Automatic
                    }
                    Start-Service -Name CcmExec
                }
                catch {
                    $Reinstall = $true
                    New-ClientInstalledReason -Log $Log -Message "Service not running, failed to start."
                }
            }

            if ( $reinstall -eq $true) {
                $text = "ConfigMgr Client Health thinks the agent need to be reinstalled. Installing and sleeping for 10 minutes for it to configure..."
                Write-Host $text
                # Lets check that registry settings are OK before we try a new installation.
                Test-CCMSetup1

                # Adding forceinstall to the client install properties to make sure previous client is uninstalled.
                if ($localDB -eq $true) { $clientInstallProperties = $clientInstallProperties + " /forceinstall" }
                Resolve-Client -Xml $xml -ClientInstallProperties $clientInstallProperties -FirstInstall $false
                $log.ClientInstalled = Get-SmallDateTime
                Start-Sleep 600
            }
        }
        else {
            $text = "Configuration Manager client is not installed. Installing and sleeping for 10 minutes for it to configure..."
            Write-Host $text
            Resolve-Client -Xml $xml -ClientInstallProperties $clientInstallProperties -FirstInstall $true
            New-ClientInstalledReason -Log $Log -Message "No agent found."
            $log.ClientInstalled = Get-SmallDateTime
            Start-Sleep 600

            # Test again if agent is installed
            if (Get-Service -Name ccmexec -ErrorAction SilentlyContinue) {}
            else { Out-LogFile -Mode "ClientInstall"}
        }
    }

    Function Test-ClientCacheSize {
        Param([Parameter(Mandatory=$true)]$Log)
        $ClientCacheSize = Get-XMLConfigClientCache
        $Cache = Get-WmiObject -Namespace "ROOT\CCM\SoftMgmtAgent" -Class CacheConfig
        $CurrentCache = Get-ClientCache

        if ($ClientCacheSize -match '%') {
            $type = 'percentage'
            # percentage based cache based on disk space
            $num = $ClientCacheSize -replace '%'
            $num = ($num / 100)
            # TotalDiskSpace in Byte
            $TotalDiskSpace = (Get-WmiObject -Class Win32_LogicalDisk | Where-Object {$_.DeviceID -eq 'C:'} | Select-Object -ExpandProperty Size)
            $ClientCacheSize = ([math]::Round(($TotalDiskSpace * $num) / 1048576))
        }
        else {
            $type = 'fixed'
        }

        if ($CurrentCache -eq $ClientCacheSize) {
            $text = "ConfigMgr Client Cache Size: OK"
            Write-Host $text
            $Log.CacheSize = $CurrentCache
            $obj = $false
        }

        else {
            switch ($type) {
                'fixed' {$text = "ConfigMgr Client Cache Size: $CurrentCache. Expected: $ClientCacheSize. Redmediating and tagging CcmExec Service for restart..."}
                'percentage' {
                    $percent = Get-XMLConfigClientCache
                    $text = "ConfigMgr Client Cache Size: $CurrentCache. Expected: $ClientCacheSize ($percent). Redmediating and tagging CcmExec Service for restart..."
                }
            }
            
            Write-Warning $text
            $Cache.Size = $ClientCacheSize
            $Cache.Put()
            $log.CacheSize = $ClientCacheSize
            $obj = $true
        }
        Write-Output $obj
    }

    Function Test-ClientVersion {
        Param([Parameter(Mandatory=$true)]$Log)
        $ClientVersion = Get-XMLConfigClientVersion
        $installedVersion = Get-ClientVersion
        $log.ClientVersion = $installedVersion

        if ($installedVersion -ge $ClientVersion) {
            $text = 'ConfigMgr Client version is: ' +$installedVersion + ': OK'
            Write-Output $text
            $obj = $false
        }
        elseif ( (Get-XMLConfigClientAutoUpgrade).ToLower() -like 'true' ) {
            $text = 'ConfigMgr Client version is: ' +$installedVersion +': Tagging client for upgrade to version: '+$ClientVersion
            Write-Warning $text
            $obj = $true
            New-ClientInstalledReason -Log $Log -Message "Version upgrade."
        }
        else {
            $text = 'ConfigMgr Client version is: ' +$installedVersion +': Required version: '+$ClientVersion +' AutoUpgrade: false. Skipping upgrade'
            Write-Output $text
            $obj = $false
        }
        Write-Output $obj
    }

    Function Test-ClientSiteCode {
        Param([Parameter(Mandatory=$true)]$Log)
        $ClientSiteCode = Get-XMLConfigClientSitecode
        $currentSiteCode = Get-Sitecode

        $Log.Sitecode = $currentSiteCode

        # Do more investigation and testing on WMI Method "SetAssignedSite" to possible avoid reinstall of client for this check.
        if ($ClientSiteCode -like $currentSiteCode) {
            
            $text = "ConfigMgr Client Site Code: OK"
            Write-Host $text
            $obj = $false
        }
        else {
            $text = 'ConfigMgr Client Site Code is ' +$currentSiteCode + ": Expected: $ClientSiteCode. Tagging client for reinstall"
            Write-Warning $text
            $obj = $true
        }
        Write-Output $obj
    }

    function Test-PendingReboot {
        Param([Parameter(Mandatory=$true)]$Log)
        # Only run pending reboot check if enabled in config
        if (($Xml.Configuration.Option | Where-Object {$_.Name -like 'PendingReboot'} | Select-Object -ExpandProperty 'Enable') -like 'True') {
            $result = @{
                CBSRebootPending =$false
                WindowsUpdateRebootRequired = $false
                FileRenamePending = $false
                SCCMRebootPending = $false
            }

            #Check CBS Registry
            $key = Get-ChildItem "HKLM:Software\Microsoft\Windows\CurrentVersion\Component Based Servicing\RebootPending" -ErrorAction SilentlyContinue
            if ($null -ne $key) 
            {
                $result.CBSRebootPending = $true
            }
    
            #Check Windows Update
            $key = Get-Item 'HKLM:SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Auto Update\RebootRequired' -ErrorAction SilentlyContinue
            if ($null -ne $key) 
            {
                $result.WindowsUpdateRebootRequired = $true
            }

            #Check PendingFileRenameOperations
            $prop = Get-ItemProperty 'HKLM:SYSTEM\CurrentControlSet\Control\Session Manager' -Name PendingFileRenameOperations -ErrorAction SilentlyContinue
            if ($null -ne $prop) 
            {
                #PendingFileRenameOperations is not *must* to reboot?
                #$result.FileRenamePending = $true
            }
        
            try 
            { 
                $util = [wmiclass]'\\.\root\ccm\clientsdk:CCM_ClientUtilities'
                $status = $util.DetermineIfRebootPending()
                if(($null -ne $status) -and $status.RebootPending){
                    $result.SCCMRebootPending = $true
                }
            }catch{}

            #Return Reboot required
            if ($result.ContainsValue($true)) {
                $text = 'Pending Reboot: Computer is in pending reboot'
                Write-Warning $text
                $log.PendingReboot = 'Pending Reboot'

                if ((Get-XMLConfigPendingRebootApp) -eq $true) {
                    Start-RebootApplication
                    $log.RebootApp = Get-SmallDateTime
                }
            }
            else {
                $text = 'Pending Reboot: OK'
                Write-Output $text
                $log.PendingReboot = 'OK'
            }
            #Out-LogFile -Xml $xml -Text $text
        }
    }

    # Functions to detect and fix errors
    Function Test-ProvisioningMode {
        Param([Parameter(Mandatory=$true)]$Log)
        $registryPath = 'HKLM:\SOFTWARE\Microsoft\CCM\CcmExec'
        $provisioningMode = (Get-ItemProperty -Path $registryPath).ProvisioningMode

        if ($provisioningMode -eq 'true') {
            $text = 'ConfigMgr Client Provisioning Mode: YES. Remediating...'
            Write-Warning $text
            Set-ItemProperty -Path $registryPath -Name ProvisioningMode -Value "false"
            $ArgumentList = @($false)
            Invoke-WmiMethod -Namespace 'root\ccm' -Class 'SMS_Client' -Name 'SetClientProvisioningMode' -ArgumentList $ArgumentList
            $log.ProvisioningMode = 'Repaired'
        }
        else {
            $text = 'ConfigMgr Client Provisioning Mode: OK'
            Write-Output $text
            $log.ProvisioningMode = 'OK'
        }
    }

    Function Update-State {
        Write-Verbose "Start Update-State"
        $SCCMUpdatesStore = New-Object -ComObject Microsoft.CCM.UpdatesStore
        $SCCMUpdatesStore.RefreshServerComplianceState()
        $log.StateMessages = 'OK'
        Write-Verbose "End Update-State"
    }

    Function Test-UpdateStore {
        Param([Parameter(Mandatory=$true)]$Log)
        Write-Verbose "Check StateMessage.log if State Messages are successfully forwarded to Management Point"
        $logdir = Get-CCMLogDirectory
        $logfile = "$logdir\StateMessage.log"
        $StateMessage = Get-Content($logfile)
        if ($StateMessage -match 'Successfully forwarded State Messages to the MP') {
            $text = 'StateMessage: OK'
            $log.StateMessages = 'OK'
            Write-Output $text
        }
        else { 
            $text = 'StateMessage: ERROR. Remediating...'
            Write-Warning $text
            Update-State
            $log.StateMessages = 'Repaired'
        }
    } 

    Function Test-RegistryPol {
        Param([Parameter(Mandatory=$true)]$Log)
        $Fixed = $false
        
        # Check 1 - Error in WUAHandler.log
        Write-Verbose 'Check WUAHandler.log if registry.pol need to be deleted'
        $logdir = Get-CCMLogDirectory
        $logfile = "$logdir\WUAHandler.log"
        $WUAHandler = Get-Content($logfile)
        $Error1 = '0x80004005'
        $Error2 = '0x87d00692'
        if ( ($WUAHandler -match $Error1) -or ($WUAHandler -match $Error2) ) {
            $text = 'GPO Cache: Error. Deleting registry.pol and running gpupdate...'
            $log.WUAHandler = 'Repaired'
            Write-Warning $text
            try { Remove-Item 'C:\Windows\System32\GroupPolicy\Machine\registry.pol' -Force }
            catch {}
            & gpupdate.exe | Out-Null
            
            Write-Verbose 'Sleeping for 1 minute to allow for group policy to refresh'
            Start-Sleep -Seconds 60

            try {
                Write-Verbose 'Temporarly stopping ccmexec service to allow for deletion of WUAHandler.log'
                Stop-Service -name ccmexec
                $newContent = $WUAHandler | Select-String -pattern $Error1 -notmatch
                Out-File -FilePath $logfile -InputObject $newContent -Encoding utf8 -Force
                #Remove-Item $logfile -Force
                Write-Verbose 'Starting ccmexec service again.'
                Start-Service -Name ccmexec
            }
            catch {}
            
            Write-Verbose 'Refreshing update policy'
            Get-SCCMPolicyScanUpdateSource
            Get-SCCMPolicySourceUpdateMessage
            $Fixed = $true
        }
                
        # Check 2 - Registry.pol is too old. No need to perform this check if check1 performed remediation.
        if ($fixed -eq $false) {
            try {
                $file = Get-ChildItem -Path 'C:\Windows\System32\GroupPolicy\Machine\registry.pol' -ErrorAction SilentlyContinue | Select-Object -First 1 -ExpandProperty LastWriteTime
                $regPolDate = Get-Date($file)
                $now = Get-Date
                if (($now - $regPolDate).Days -ge 5) {
                    $text = 'GPO Cache: Error. Deleting registry.pol and run gpupdate...'
                    Write-Warning $text
                    $log.WUAHandler = 'Repaired'
                    try { Remove-Item 'C:\Windows\System32\GroupPolicy\Machine\registry.pol' -Force  }
                    catch {}
                    & gpupdate.exe | Out-Null
                    Get-SCCMPolicyScanUpdateSource
                    Get-SCCMPolicySourceUpdateMessage
                    $Fixed = $true
                }
                
                if ($Fixed -eq $false) {
                    $text = 'GPO Cache: OK'
                    $log.WUAHandler = 'OK'
                    Write-Output $text
                }
            }
            catch {
                $text = 'GPO Cache: OK'
                $log.WUAHandler = 'OK'
                Write-Output $text
            }
        }
    }

    Function Test-ClientLogSize {
        Param([Parameter(Mandatory=$true)]$Log)
        try {
            $currentLogSize = Get-ClientMaxLogSize
        } catch {
            $currentLogSize = 0
        }
        try {
            $currentMaxHistory = Get-ClientMaxLogHistory
        } catch {
            $currentMaxHistory = 0
        }
        try {
            $logLevel = (Get-ItemProperty -Path 'HKLM:\SOFTWARE\Microsoft\CCM\Logging\@Global').logLevel
        } catch {
            $logLevel = 1
        }
        $clientLogSize = Get-XMLConfigClientMaxLogSize
        $clientLogMaxHistory = Get-XMLConfigClientMaxLogHistory

        $text = ''

        if ( ($currentLogSize -eq $clientLogSize) -and ($currentMaxHistory -eq $clientLogMaxHistory) ) {
            $Log.MaxLogSize = $currentLogSize
            $Log.MaxLogHistory = $currentMaxHistory
            $text = "ConfigMgr Client Max Log Size: OK ($currentLogSize)"
            Write-Host $text
            $text = "ConfigMgr Client Max Log History: OK ($currentMaxHistory)"
            Write-Host $text
            $obj = $false
        }
        else {
            if ($currentLogSize -ne $clientLogSize) {
                $text = 'ConfigMgr Client Max Log Size: Configuring to '+ $clientLogSize +' KB'
                $Log.MaxLogSize = $clientLogSize
                Write-Warning $text
            }
            else {
                $text = "ConfigMgr Client Max Log Size: OK ($currentLogSize)"
                Write-Host $text
            }
            if ($currentMaxHistory -ne $clientLogMaxHistory) {
                $text = 'ConfigMgr Client Max Log History: Configuring to ' +$clientLogMaxHistory
                $Log.MaxLogHistory = $clientLogMaxHistory
                Write-Warning $text
            }
            else {
                $text = "ConfigMgr Client Max Log History: OK ($currentMaxHistory)"
                Write-Host $text
            }

            $newLogSize = [int]$clientLogSize
            $newLogSize = $newLogSize * 1000

            $smsClient = [wmiclass]"root/ccm:sms_client"
            $smsClient.SetGlobalLoggingConfiguration($logLevel, $newLogSize, $clientLogMaxHistory)
            #Write-Verbose 'Returning true to trigger restart of ccmexec service'

            #Write-Verbose 'Sleeping for 5 seconds to allow WMI method complete before we collect new results...'
            #Start-Sleep -Seconds 5

            try {
                $Log.MaxLogSize = Get-ClientMaxLogSize
            } catch {
                $Log.MaxLogSize = 0
            }
            try {
                $Log.MaxLogHistory = Get-ClientMaxLogHistory
            } catch {
                $Log.MaxLogHistory = 0
            }
            $obj = $true
        }
        Write-Output $obj
    }

    Function Resolve-Client {
        Param(
            [Parameter(Mandatory=$false)]$Xml,
            [Parameter(Mandatory=$true)]$ClientInstallProperties,
            [Parameter(Mandatory=$false)]$FirstInstall=$false
            )

        $ClientShare = $Xml.Configuration.Client | Where-Object {$_.Name -like 'Share'} | Select-Object -ExpandProperty '#Text'
        if ((Test-Path $ClientShare -ErrorAction SilentlyContinue) -eq $true) {
            if ($FirstInstall -eq $true) {
                $text = 'Installing Configuration Manager Client.'
            } 
            else {
                $text = 'Client tagged for reinstall. Reinstalling client...'
            }
            Write-Output $text
            
            Write-Verbose "Perform a test on a specific registry key required for ccmsetup to succeed."
            Test-CCMSetup1
            
            Write-Verbose "Enforce registration of common DLL files to make sure CCM Agent works."
            $DllFiles = 'actxprxy.dll', 'atl.dll', 'Bitsprx2.dll', 'Bitsprx3.dll', 'browseui.dll', 'cryptdlg.dll', 'dssenh.dll', 'gpkcsp.dll', 'initpki.dll', 'jscript.dll', 'mshtml.dll', 'msi.dll', 'mssip32.dll', 'msxml.dll', 'msxml3.dll', 'msxml3a.dll', 'msxml3r.dll', 'msxml4.dll', 'msxml4a.dll', 'msxml4r.dll', 'msxml6.dll', 'msxml6r.dll', 'muweb.dll', 'ole32.dll', 'oleaut32.dll', 'Qmgr.dll', 'Qmgrprxy.dll', 'rsaenh.dll', 'sccbase.dll', 'scrrun.dll', 'shdocvw.dll', 'shell32.dll', 'slbcsp.dll', 'softpub.dll', 'rlmon.dll', 'userenv.dll', 'vbscript.dll', 'Winhttp.dll', 'wintrust.dll', 'wuapi.dll', 'wuaueng.dll', 'wuaueng1.dll', 'wucltui.dll', 'wucltux.dll', 'wups.dll', 'wups2.dll', 'wuweb.dll', 'wuwebv.dll', 'Xpob2res.dll', 'WBEM\wmisvc.dll'
            foreach ($Dll in $DllFiles) {
                $file =  $env:windir +"\$Dll"
                Register-DLLFile -FilePath $File
            }

            Write-Verbose "Trigger ConfigMgr Client installation using Invoke-Expression."
            Invoke-Expression "&'$ClientShare\ccmsetup.exe' $ClientInstallProperties"
        }
        else {
            $text = 'ERROR: Client tagged for reinstall, but failed to access fileshare: ' +$ClientShare
            Write-Error $text
            Exit 1
        }
    }

    function Register-DLLFile {
        [CmdletBinding()]
        param ([string]$FilePath)

        try {
            $Result = Start-Process -FilePath 'regsvr32.exe' -Args "/s `"$FilePath`"" -Wait -NoNewWindow -PassThru
        } catch {}
    }

    Function Test-WMI {
        Param([Parameter(Mandatory=$true)]$Log)
        $vote = 0

        $result = winmgmt /verifyrepository
        switch -wildcard ($result) {
            # Always fix if this returns inconsistent
            "*inconsistent*" { $vote = 100} # English
            "*not consistent*"  { $vote = 100} # English
            "*inkonsekvent*" { $vote = 100} # Swedish            
            # Add more languages as I learn their inconsistent value
        }

        Try {
            $WMI = Get-WmiObject Win32_ComputerSystem -ErrorAction Stop
        } Catch {
            Write-Verbose 'Failed to connect to WMI class "Win32_ComputerSystem". Voting for WMI fix...'
            $vote++
        }

        Try {
            $WMI = Get-WmiObject -Namespace root/ccm -Class SMS_Client -ErrorAction Stop
        } Catch {
            Write-Verbose 'Failed to connect to WMI namespace "root/ccm" class "SMS_Client". Tagging client for reinstall instead of WMI fix.'
            $obj = $true
        } Finally {
            if ($vote -eq 0) {
                $text = 'WMI Check: OK'
                $log.WMI = 'OK'
                Write-Host $text
                $obj = $false
            }
            else {
                $fix = Get-XMLConfigWMIRepairEnable
                if ($fix -like "True") {
                    $text = 'WMI Check: Corrupt. Attempting to repair WMI and reinstall ConfigMgr client.'
                    Write-Warning $text
                    Repair-WMI
                    $log.WMI = 'Repaired'
                }
                else {
                    $text = 'WMI Check: Corrupt. Autofix is disabled'
                    Write-Warning $text
                    $log.WMI = 'Corrupt'
                }
                Write-Verbose "returning true to tag client for reinstall" 
                $obj = $true
            }
            #Out-LogFile -Xml $xml -Text $text
            Write-Output $obj
        }
    }

    Function Repair-WMI {
        $text ='Repairing WMI'
        Write-Output $text
        
        # Check PATH
        if((! (@(($ENV:PATH).Split(";")) -contains "c:\WINDOWS\System32\Wbem")) -and (! (@(($ENV:PATH).Split(";")) -contains "%systemroot%\System32\Wbem"))){
            $text = "WMI Folder not in search path!."
            Write-Warning $text
        }
        # Stop WMI
        Stop-Service -Force ccmexec -ErrorAction SilentlyContinue 
        Stop-Service -Force winmgmt

        # WMI Binaries
        [String[]]$aWMIBinaries=@("unsecapp.exe","wmiadap.exe","wmiapsrv.exe","wmiprvse.exe","scrcons.exe")
        foreach ($sWMIPath in @(($ENV:SystemRoot+"\System32\wbem"),($ENV:SystemRoot+"\SysWOW64\wbem"))) {
            if(Test-Path -Path $sWMIPath){
                push-Location $sWMIPath
                foreach($sBin in $aWMIBinaries){
                    if(Test-Path -Path $sBin){
                        $oCurrentBin=Get-Item -Path  $sBin
                        & $oCurrentBin.FullName /RegServer
                    }
                    else{
                        # Warning only for System32
                        if($sWMIPath -eq $ENV:SystemRoot+"\System32\wbem"){
                            Write-Warning "File $sBin not found!"
                        }
                    }
                }
                Pop-Location
            }
        }

        # Reregister Managed Objects
        Write-Verbose "Reseting Repository..."
        & ($ENV:SystemRoot+"\system32\wbem\winmgmt.exe") /resetrepository
        & ($ENV:SystemRoot+"\system32\wbem\winmgmt.exe") /salvagerepository
        Start-Service winmgmt
        $text = 'Tagging ConfigMgr client for reinstall'
        Write-Warning $text
    }

    # Start ConfigMgr Agent if not already running
    Function Test-SCCMService {
        if ($service.Status -ne 'Running') {
            try {Start-Service -Name CcmExec | Out-Null}
            catch {}
        }
    }

    # Windows Service Functions
    Function Test-Services {
        Param([Parameter(Mandatory=$true)]$Xml, $log)

        $log.Services = 'OK'
        Write-Verbose 'Test services from XML configuration file'
        foreach ($service in $Xml.Configuration.Service) {
            $startuptype = ($service.StartupType).ToLower()
            if ($startuptype -like "automatic (delayed start)") {
                $service.StartupType = "automaticd"
            }
            Test-Service -Name $service.Name -StartupType $service.StartupType -State $service.State -Log $log
            
        }
    }

    Function Test-Service {
        param(
        [Parameter(Mandatory=$True,
                    HelpMessage='Name')]
                    [string]$Name,
        [Parameter(Mandatory=$True,
                    HelpMessage='StartupType: Automatic, Automatic (Delayed Start), Manual, Disabled')]
                    [string]$StartupType,
        [Parameter(Mandatory=$True,
                    HelpMessage='State: Running, Stopped')]
                    [string]$State,
        [Parameter(Mandatory=$True)]$log
        )

        $OSName = Get-OperatingSystem

        # Handle all sorts of casing and mispelling of delayed and triggerd start in config.xml services
        $val = $StartupType.ToLower()
        switch -Wildcard ($val) {
            "automaticd*" {$StartupType = "Automatic (Delayed Start)"}
            "automatic(d*" {$StartupType = "Automatic (Delayed Start)"}
            "automatic(t*" {$StartupType = "Automatic (Trigger Start)"}
            "automatict*" {$StartupType = "Automatic (Trigger Start)"}
        }

        $path = "HKLM:\SYSTEM\CurrentControlSet\Services\$name"
        
        $DelayedAutostart = (Get-ItemProperty -Path $path).DelayedAutostart
        if ($DelayedAutostart -ne 1) {
            $DelayedAutostart = 0
        }

        $service = Get-Service -Name $Name
        $WMIService = Get-WmiObject -Class Win32_Service -Property StartMode -Filter "Name='$Name'"
        $StartMode = ($WMIService.StartMode).ToLower()
        
        switch -Wildcard ($StartMode) {
            "auto*" {
                if ($DelayedAutostart -eq 1) {
                    $serviceStartType = "Automatic (Delayed Start)"
                }
                else {
                    # Default = automatic
                    $serviceStartType = "Automatic"
                }
            }

            <# This will be implemented at a later time.
            "automatic d*" {$serviceStartType = "Automatic (Delayed Start)"}
            "automatic (d*" {$serviceStartType = "Automatic (Delayed Start)"}
            "automatic (t*" {$serviceStartType = "Automatic (Trigger Start)"}
            "automatic t*" {$serviceStartType = "Automatic (Trigger Start)"}
            #>
            "manual" {$serviceStartType = "Manual"}
            "disabled" {$serviceStartType = "Disabled"}
        }

        Write-Verbose "Verify startup type"
        if ($serviceStartType -eq $StartupType)
        {
            $text = "Service $Name startup: OK"
            Write-Output $text
        }
        elseif ($StartupType -like "Automatic (Delayed Start)") {
            # Handle Automatic Trigger Start the dirty way for these two services. Implement in a nice way in future version.
            if ( (($name -eq "wuauserv") -or ($name -eq "W32Time")) -and (($OSName -like "Windows 10*") -or ($OSName -like "*Server 2016*")) ) {
                if ($service.StartType -ne "Automatic") {
                    $text = "Configuring service $Name StartupType to: Automatic (Trigger Start)..."
                    Set-Service -Name $service.Name -StartupType Automatic
                }
                else {
                    "Service $Name startup: OK"
                }
                Write-Output $text
            }
            else {
                # Automatic delayed requires the use of sc.exe
                & sc.exe config $service start= delayed-auto | Out-Null
                $text = "Configuring service $Name StartupType to: $StartupType..."
                Write-Output $text
                $log.Services = 'Started'
            }
            
        }

        else {
            try {
                $text = "Configuring service $Name StartupType to: $StartupType..."
                Write-Output $text
                Set-Service -Name $service.Name -StartupType $StartupType
                $log.Services = 'Started'
            } catch {
                $text = "Failed to set $StartupType StartupType on service $Name"
                Write-Error $text
            } finally {
            }
        }
        
        Write-Verbose 'Verify service is running'
        if ($service.Status -eq "Running") {
            $text = 'Service ' +$Name+' running: OK'
            Write-Output $text
        }
        else {
            try {
                $text = 'Starting service: ' + $Name + '...'
                Write-Output $text
                Start-Service -Name $service.Name
                $log.Services = 'Started'
            } catch {
                $text = 'Failed to start service ' +$Name
                Write-Error $text
            }
        }
    }

    function Test-AdminShare {
        Param([Parameter(Mandatory=$true)]$Log)
        Write-Verbose "Test the ADMIN$ and C$"

        $share = Get-WmiObject Win32_Share | Where-Object {$_.Name -like 'ADMIN$'}
        $shareClass = [WMICLASS]”WIN32_Share”

        if ($share.Name -contains 'ADMIN$') {
            $text = 'Adminshare Admin$: OK'
            Write-Output $text
        }
        else {
            $fix = $true
        }
        
        $share = Get-WmiObject Win32_Share | Where-Object {$_.Name -like 'C$'}
        $shareClass = [WMICLASS]'WIN32_Share'

        if ($share.Name -contains "C$") {
            $text = 'Adminshare C$: OK'
            Write-Output $text
        }
        else {
            $fix = $true
        }

        if ($fix -eq $true) {
            $text = 'Error with Adminshares. Remediating...'
            $log.AdminShare = 'Repaired'
            Write-Warning $text
            Stop-Service server -Force
            Start-Service server
        }
        else {
            $log.AdminShare = 'OK'
        }
    }

    Function Test-DiskSpace {
        $XMLDiskSpace = Get-XMLConfigOSDiskFreeSpace
        $driveC = Get-WmiObject -Class Win32_LogicalDisk | Where-Object {$_.DeviceID -eq 'C:'} | Select-Object FreeSpace, Size
        $freeSpace = (($driveC.FreeSpace / $driveC.Size) * 100)

        if ($freeSpace -le $XMLDiskSpace) {
            $text = 'Local disk C: Less than '+$XMLDiskSpace +'% free space'
            Write-Error $text
        }
        else {
            $text = 'Free space C: OK'
            Write-Output $text
        }
        #Out-LogFile -Xml $xml -Text $text
    }

    Function Test-CCMSoftwareDistribution {
        Get-WmiObject -Class CCM_SoftwareDistributionClientConfig
    }

    Function Get-UBR {
        $UBR = (Get-ItemProperty -Path 'HKLM:\Software\Microsoft\Windows NT\CurrentVersion').UBR
        Write-Output $UBR
    }

    Function Get-LastReboot {
        Param([Parameter(Mandatory=$true)][xml]$Xml)

        # Only run if option in config is enabled
        if (($Xml.Configuration.Option | Where-Object {$_.Name -like 'RebootApplication'} | Select-Object -ExpandProperty 'Enable') -like 'True') {

            [float]$maxRebootDays = Get-XMLConfigMaxRebootDays
            $wmi = Get-WmiObject Win32_OperatingSystem
            $lastBootTime = $wmi.ConvertToDateTime($wmi.LastBootUpTime)

            $uptime = (Get-Date) - ($wmi.ConvertToDateTime($wmi.lastbootuptime))
            if ($uptime.TotalDays -lt $maxRebootDays) {
                $text = 'Last boot time: ' +$lastBootTime + ': OK'
                Write-Output $text
            }
            elseif (($uptime.TotalDays -ge $maxRebootDays) -and (Get-XMLConfigRebootApplicationEnable -eq $true)) {
                $text = 'Last boot time: ' +$lastBootTime + ': More than '+$maxRebootDays +' days since last reboot. Starting reboot application.'
                Write-Warning $text
                Start-RebootApplication
            }
            else {
                $text = 'Last boot time: ' +$lastBootTime + ': More than '+$maxRebootDays +' days since last reboot. Reboot application disabled.'
                Write-Warning $text
            }
        }
    }

    Function Start-RebootApplication {
        $taskName = 'ConfigMgr Client Health - Reboot on demand'
        
        $OS = Get-OperatingSystem
        if ($OS -like "*Windows 7*") {
            $task = schtasks.exe /query | FIND /I "ConfigMgr Client Health - Reboot"
        } else {
            $task = Get-ScheduledTask -TaskName $taskName -ErrorAction SilentlyContinue
        }
        
        if ($task -eq $null) {
            New-RebootTask -taskName $taskName
        }
        
        if ($OS -notlike "*Windows 7*")
        {
            Start-ScheduledTask -TaskName $taskName
        }
        else
        {
            schtasks.exe /Run /TN $taskName
        }
    }

    Function New-RebootTask {
        Param([Parameter(Mandatory=$true)]$taskName)

        $rebootApp = Get-XMLConfigRebootApplication

        # $execute is the executable file, $arguement is all the arguments added to it.
        $execute,$arguments = $rebootApp.Split(' ')
        $argument = $null

        foreach ($i in $arguments) {
            $argument += $i + " "
        }

        # Trim the " " from argument if present
        $i = $argument.Length -1
        if ($argument.Substring($i) -eq ' ') {
            $argument = $argument.Substring(0, $argument.Length -1)
        }

        $OS = Get-OperatingSystem
        if ($OS -like "*Windows 7*") {
            schtasks.exe /Create /tn $taskName /tr "$execute $argument" /ru "BUILTIN\Users" /sc ONCE /st 00:00 /sd 01/01/1901
        } else {
            $action = New-ScheduledTaskAction -Execute $execute -Argument $argument
            $userPrincipal = New-ScheduledTaskPrincipal -GroupId "S-1-5-32-545"
            Register-ScheduledTask -Action $action -TaskName $taskName -Principal $userPrincipal | Out-Null
        }
    }

    Function Start-Ccmeval {
        Write-Host "Starting built-in Configuration Manager Health Evaluation"
        $task = "Microsoft\Configuration Manager\Configuration Manager Health Evaluation"
        schtasks.exe /Run /TN $task
    }

    Function Test-MissingDrivers {
        Param([Parameter(Mandatory=$true)]$Log)
        $i = 0
        $devices = Get-WmiObject Win32_PNPEntity | Where-Object{ ($_.ConfigManagerErrorCode -ne 0) -and ($_.ConfigManagerErrorCode -ne 22) -and ($_.Name -notlike "*PS/2*") } | Select-Object Name, DeviceID
        $devices | ForEach-Object {$i++} 

        if ($devices -ne $null) {
            $text = "Drivers: $i unknown or faulty device(s)" 
            Write-Warning $text
            $log.Drivers = "$i unknown or faulty driver(s)" 
            
            foreach ($device in $devices) {
                $text = 'Missing or faulty driver: ' +$device.Name + '. Device ID: ' + $device.DeviceID
                Write-Warning $text
                Out-LogFile -Xml $xml -Text $text
            }
        }
        else {
            $text = "Drivers: OK"
            Write-Output $text
            $log.Drivers = 'OK' 
        }
    }

    # Function to store SCCM log file changes to be processed
    Function New-SCCMLogFileJob {
        Param(
            [Parameter(Mandatory=$true)]$Logfile,
            [Parameter(Mandatory=$true)]$Text,
            [Parameter(Mandatory=$true)]$SCCMLogJobs
        )

        $path = Get-CCMLogDirectory
        $file = "$path\$LogFile"
        $SCCMLogJobs.Rows.Add($file, $text)
    }

    # Function to remove info in SCCM logfiles after remediation. This to prevent false positives triggering remediation next time script runs
    Function Update-SCCMLogFile {
        Param([Parameter(Mandatory=$true)]$SCCMLogJobs)
        Write-Verbose "Start Update-SCCMLogFile"
        
        foreach ($job in $SCCMLogJobs) {
            #get-content -Path $file | select-string -pattern $text -notmatch | Out-File $file -Force
            get-content -Path $job.File | Where-Object {$_ -notmatch $job.Text} | Out-File $job.File -Force
        }

        Write-Verbose "End Update-SCCMLogFile"
    }

    Function Test-SCCMHardwareInventoryScan {
        Param([Parameter(Mandatory=$true)]$Log)
        
        Write-Verbose "Start Test-SCCMHardwareInventoryScan"
        $days = Get-XMLConfigHardwareInventoryDays
        $wmi = Get-WmiObject -Namespace root\ccm\invagt -Class InventoryActionStatus | Where-Object {$_.InventoryActionID -eq '{00000000-0000-0000-0000-000000000001}'} | Select-Object @{label='HWSCAN';expression={$_.ConvertToDateTime($_.LastCycleStartedDate)}}
        $HWScanDate = $wmi | Select-Object -ExpandProperty HWSCAN
        $HWScanDate = Get-SmallDateTime $HWScanDate
        $minDate = Get-SmallDateTime((Get-Date).AddDays(-$days))
        if ($HWScanDate -le $minDate) {
            $fix = (Get-XMLConfigHardwareInventoryFix).ToLower()
            if ($fix -eq "true") {
                $text = "ConfigMgr Hardware Inventory scan: $HWScanDate. Starting hardware inventory scan of the client."
                Write-Host $Text
                Get-SCCMPolicyHardwareInventory
                
                # Get the new date after policy trigger
                $wmi = Get-WmiObject -Namespace root\ccm\invagt -Class InventoryActionStatus | Where-Object {$_.InventoryActionID -eq '{00000000-0000-0000-0000-000000000001}'} | Select-Object @{label='HWSCAN';expression={$_.ConvertToDateTime($_.LastCycleStartedDate)}}
                $HWScanDate = $wmi | Select-Object -ExpandProperty HWSCAN
                $HWScanDate = Get-SmallDateTime -Date $HWScanDate
            }
            else {
                # No need to update anything if fix = false. Last date will still be set in log
            }

                        
        }
        else {
            $text = "ConfigMgr Hardware Inventory scan: OK"
            Write-Output $text
        }
        $log.HWInventory = $HWScanDate
        Write-Verbose "End Test-SCCMHardwareInventoryScan"
    }

    # Get the clients SiteName in Active Directory
    Function Get-ClientSiteName {
        try {$obj = (Get-WmiObject Win32_NTDomain).ClientSiteName}
        catch {$obj = $false}
        finally {
            if ($obj -ne $false) {
                Write-Output ($obj | Select-Object -First 1)
            }
        }
    }

    Function Test-SoftwareMeteringPrepDriver {
        Param([Parameter(Mandatory=$true)]$Log)
        # To execute function: if (Test-SoftwareMeteringPrepDriver -eq $false) {$restartCCMExec = $true}
        # Thanks to Paul Andrews for letting me know about this issue.
        # And Sherry Kissinger for a nice fix: https://mnscug.org/blogs/sherry-kissinger/481-configmgr-ccmrecentlyusedapps-blank-or-mtrmgr-log-with-startprepdriver-openservice-failed-with-error-issue

        Write-Verbose "Start Test-SoftwareMeteringPrepDriver"
        
        $logdir = Get-CCMLogDirectory
        $logfile = "$logdir\mtrmgr.log"
        $content = Get-Content -Path $logfile
        $error1 = "StartPrepDriver - OpenService Failed with Error"
        $error2 = "Software Metering failed to start PrepDriver"

        if (($content -match $error1) -or ($content -match $error2)) {
            $fix = (Get-XMLConfigSoftwareMeteringFix).ToLower()
            
            if ($fix -eq "true") {
                $Text = "Software Metering - PrepDriver: Error. Remediating..."
                Write-Host $Text
                $CMClientDIR = (Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\SMS\Client\Configuration\Client Properties" -Name 'Local SMS Path').'Local SMS Path'
                $ExePath = $env:windir + '\system32\RUNDLL32.EXE'
                $CLine = ' SETUPAPI.DLL,InstallHinfSection DefaultInstall 128 ' + $CMClientDIR + 'prepdrv.inf'
                $ExePath = $env:windir + '\system32\RUNDLL32.EXE'
                $Prms = $Cline.Split(" ")
                & "$Exepath" $Prms
                
                $newContent = $content | Select-String -pattern $error1, $error2 -notmatch
                Stop-Service -Name CcmExec
                Out-File -FilePath $logfile -InputObject $newContent -Encoding utf8 -Force
                Start-Service -Name CcmExec
                            
                $Obj = $false
                $Log.SWMetering = "Remediated"
            }
            else {
                # Set $obj to true as we don't want to do anything with the CM agent.
                $obj = $true
                $Log.SWMetering = "Error"
            }
        }
        else {
            $Text = "Software Metering - PrepDriver: OK"
            Write-Host $Text
            $Obj = $true
            $Log.SWMetering = "OK"
        }
        $content = $null # Clean the variable containing the log file.

        Write-Output $Obj
        Write-Verbose "End Test-SoftwareMeteringPrepDriver"
    }

    Function Test-SCCMHWScanErrors {
        # Function to test and fix errors that prevent a computer to perform a HW scan. Not sure if this is really needed or not.
    }

    # SCCM Client evaluation policies
    Function Get-SCCMPolicySourceUpdateMessage {
        $trigger = "{00000000-0000-0000-0000-000000000032}"
        Invoke-WmiMethod -Namespace root\ccm -Class sms_client -Name TriggerSchedule $trigger -ErrorAction SilentlyContinue | Out-Null
    }

    Function Get-SCCMPolicySendUnsentStateMessages {
        $trigger = "{00000000-0000-0000-0000-000000000111}"
        Invoke-WmiMethod -Namespace root\ccm -Class sms_client -Name TriggerSchedule $trigger -ErrorAction SilentlyContinue | Out-Null
    }

    Function Get-SCCMPolicyScanUpdateSource {
        $trigger = "{00000000-0000-0000-0000-000000000113}"
        Invoke-WmiMethod -Namespace root\ccm -Class sms_client -Name TriggerSchedule $trigger -ErrorAction SilentlyContinue | Out-Null
    }

    Function Get-SCCMPolicyHardwareInventory {
        $trigger = "{00000000-0000-0000-0000-000000000001}"
        Invoke-WmiMethod -Namespace root\ccm -Class sms_client -Name TriggerSchedule $trigger -ErrorAction SilentlyContinue | Out-Null
    }

    Function Get-SCCMPolicyMachineEvaluation {
        $trigger = "{00000000-0000-0000-0000-000000000022}"
        Invoke-WmiMethod -Namespace root\ccm -Class sms_client -Name TriggerSchedule $trigger -ErrorAction SilentlyContinue | Out-Null
    }

    Function Get-Version {
        $text = 'ConfigMgr Client Health Version ' +$Version
        Write-Output $text
        Out-LogFile -Xml $xml -Text $text
    }

    <# Trigger codes
    {00000000-0000-0000-0000-000000000001} Hardware Inventory
    {00000000-0000-0000-0000-000000000002} Software Inventory 
    {00000000-0000-0000-0000-000000000003} Discovery Inventory 
    {00000000-0000-0000-0000-000000000010} File Collection 
    {00000000-0000-0000-0000-000000000011} IDMIF Collection 
    {00000000-0000-0000-0000-000000000012} Client Machine Authentication 
    {00000000-0000-0000-0000-000000000021} Request Machine Assignments 
    {00000000-0000-0000-0000-000000000022} Evaluate Machine Policies 
    {00000000-0000-0000-0000-000000000023} Refresh Default MP Task 
    {00000000-0000-0000-0000-000000000024} LS (Location Service) Refresh Locations Task 
    {00000000-0000-0000-0000-000000000025} LS (Location Service) Timeout Refresh Task 
    {00000000-0000-0000-0000-000000000026} Policy Agent Request Assignment (User) 
    {00000000-0000-0000-0000-000000000027} Policy Agent Evaluate Assignment (User) 
    {00000000-0000-0000-0000-000000000031} Software Metering Generating Usage Report 
    {00000000-0000-0000-0000-000000000032} Source Update Message
    {00000000-0000-0000-0000-000000000037} Clearing proxy settings cache 
    {00000000-0000-0000-0000-000000000040} Machine Policy Agent Cleanup 
    {00000000-0000-0000-0000-000000000041} User Policy Agent Cleanup
    {00000000-0000-0000-0000-000000000042} Policy Agent Validate Machine Policy / Assignment 
    {00000000-0000-0000-0000-000000000043} Policy Agent Validate User Policy / Assignment 
    {00000000-0000-0000-0000-000000000051} Retrying/Refreshing certificates in AD on MP 
    {00000000-0000-0000-0000-000000000061} Peer DP Status reporting 
    {00000000-0000-0000-0000-000000000062} Peer DP Pending package check schedule 
    {00000000-0000-0000-0000-000000000063} SUM Updates install schedule 
    {00000000-0000-0000-0000-000000000071} NAP action 
    {00000000-0000-0000-0000-000000000101} Hardware Inventory Collection Cycle 
    {00000000-0000-0000-0000-000000000102} Software Inventory Collection Cycle 
    {00000000-0000-0000-0000-000000000103} Discovery Data Collection Cycle 
    {00000000-0000-0000-0000-000000000104} File Collection Cycle 
    {00000000-0000-0000-0000-000000000105} IDMIF Collection Cycle 
    {00000000-0000-0000-0000-000000000106} Software Metering Usage Report Cycle 
    {00000000-0000-0000-0000-000000000107} Windows Installer Source List Update Cycle 
    {00000000-0000-0000-0000-000000000108} Software Updates Assignments Evaluation Cycle 
    {00000000-0000-0000-0000-000000000109} Branch Distribution Point Maintenance Task 
    {00000000-0000-0000-0000-000000000110} DCM policy 
    {00000000-0000-0000-0000-000000000111} Send Unsent State Message 
    {00000000-0000-0000-0000-000000000112} State System policy cache cleanout 
    {00000000-0000-0000-0000-000000000113} Scan by Update Source 
    {00000000-0000-0000-0000-000000000114} Update Store Policy 
    {00000000-0000-0000-0000-000000000115} State system policy bulk send high
    {00000000-0000-0000-0000-000000000116} State system policy bulk send low 
    {00000000-0000-0000-0000-000000000120} AMT Status Check Policy 
    {00000000-0000-0000-0000-000000000121} Application manager policy action 
    {00000000-0000-0000-0000-000000000122} Application manager user policy action
    {00000000-0000-0000-0000-000000000123} Application manager global evaluation action 
    {00000000-0000-0000-0000-000000000131} Power management start summarizer
    {00000000-0000-0000-0000-000000000221} Endpoint deployment reevaluate 
    {00000000-0000-0000-0000-000000000222} Endpoint AM policy reevaluate 
    {00000000-0000-0000-0000-000000000223} External event detection
    #>

    function Test-SQLConnection {    
        $SQLServer = Get-XMLConfigSQLServer
        $Database = 'ClientHealth'

        $ConnectionString = "Server={0};Database={1};Integrated Security=True;" -f $SQLServer,$Database

        try
        {
            $sqlConnection = New-Object System.Data.SqlClient.SqlConnection $ConnectionString;
            $sqlConnection.Open();
            $sqlConnection.Close();

            $obj = $true;
        } catch {
            $text = "Error connecting to SQLDatabase $Database on SQL Server $SQLServer"
            Write-Error -Message $text
            Out-LogFile -Xml $xml -Text $text
            $obj = $false;
        } finally {
            Write-Output $obj
        }
    }

    # Invoke-SqlCmd2 - Created by Chad Miller
    function Invoke-Sqlcmd2 
    { 
        [CmdletBinding()] 
        param( 
        [Parameter(Position=0, Mandatory=$true)] [string]$ServerInstance, 
        [Parameter(Position=1, Mandatory=$false)] [string]$Database, 
        [Parameter(Position=2, Mandatory=$false)] [string]$Query, 
        [Parameter(Position=3, Mandatory=$false)] [string]$Username, 
        [Parameter(Position=4, Mandatory=$false)] [string]$Password, 
        [Parameter(Position=5, Mandatory=$false)] [Int32]$QueryTimeout=600, 
        [Parameter(Position=6, Mandatory=$false)] [Int32]$ConnectionTimeout=15, 
        [Parameter(Position=7, Mandatory=$false)] [ValidateScript({test-path $_})] [string]$InputFile, 
        [Parameter(Position=8, Mandatory=$false)] [ValidateSet("DataSet", "DataTable", "DataRow")] [string]$As="DataRow" 
        ) 
    
        if ($InputFile) 
        { 
            $filePath = $(resolve-path $InputFile).path 
            $Query =  [System.IO.File]::ReadAllText("$filePath") 
        } 
    
        $conn=new-object System.Data.SqlClient.SQLConnection 
        
        if ($Username) 
        { $ConnectionString = "Server={0};Database={1};User ID={2};Password={3};Trusted_Connection=False;Connect Timeout={4}" -f $ServerInstance,$Database,$Username,$Password,$ConnectionTimeout } 
        else 
        { $ConnectionString = "Server={0};Database={1};Integrated Security=True;Connect Timeout={2}" -f $ServerInstance,$Database,$ConnectionTimeout } 
    
        $conn.ConnectionString=$ConnectionString 
        
        #Following EventHandler is used for PRINT and RAISERROR T-SQL statements. Executed when -Verbose parameter specified by caller 
        if ($PSBoundParameters.Verbose) 
        { 
            $conn.FireInfoMessageEventOnUserErrors=$true 
            $handler = [System.Data.SqlClient.SqlInfoMessageEventHandler] {Write-Verbose "$($_)"} 
            $conn.add_InfoMessage($handler) 
        } 
        
        $conn.Open() 
        $cmd=new-object system.Data.SqlClient.SqlCommand($Query,$conn) 
        $cmd.CommandTimeout=$QueryTimeout 
        $ds=New-Object system.Data.DataSet 
        $da=New-Object system.Data.SqlClient.SqlDataAdapter($cmd) 
        [void]$da.fill($ds) 
        $conn.Close() 
        switch ($As) 
        { 
            'DataSet'   { Write-Output ($ds) } 
            'DataTable' { Write-Output ($ds.Tables) } 
            'DataRow'   { Write-Output ($ds.Tables[0]) } 
        } 
    }


    # Gather info about the computer
    Function Get-Info {
        $OS = Get-WmiObject Win32_OperatingSystem
        $ComputerSystem = Get-WmiObject Win32_ComputerSystem

        if ($ComputerSystem.Manufacturer -like 'Lenovo') {
            $Model = (Get-WmiObject Win32_ComputerSystemProduct).Version
        }
        else {
            $Model = $ComputerSystem.Model
        }

        $obj = New-Object PSObject -Property @{
            Hostname = $ComputerSystem.Name;
            Manufacturer = $ComputerSystem.Manufacturer
            Model = $Model
            Operatingsystem = $OS.Caption;
            Architecture = $OS.OSArchitecture;
            Build = $OS.BuildNumber;
            InstallDate = Get-SmallDateTime -Date ($OS.ConvertToDateTime($OS.InstallDate))
            LastLoggedOnUser = (Get-ItemProperty -Path 'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Authentication\LogonUI\').LastLoggedOnUser;
        }

        $obj = $obj
        Write-Output $obj
    }

    # Start Getters - XML config file
    Function Get-LocalFilesPath {
        $obj = $Xml.Configuration.LocalFiles
        Write-Output $obj
    }
    
    Function Get-XMLConfigClientVersion {
        $obj = $Xml.Configuration.Client | Where-Object {$_.Name -like 'Version'} | Select-Object -ExpandProperty '#text'
        Write-Output $obj
    }

    Function Get-XMLConfigClientSitecode {
        $obj = $Xml.Configuration.Client | Where-Object {$_.Name -like 'SiteCode'} | Select-Object -ExpandProperty '#text'
        Write-Output $obj
    }

    Function Get-XMLConfigClientDomain {
        $obj = $Xml.Configuration.Client | Where-Object {$_.Name -like 'Domain'} | Select-Object -ExpandProperty '#text'
        Write-Output $obj
    }

    Function Get-XMLConfigClientAutoUpgrade {
        $obj = $Xml.Configuration.Client | Where-Object {$_.Name -like 'AutoUpgrade'} | Select-Object -ExpandProperty '#text'
        Write-Output $obj
    }

    Function Get-XMLConfigClientMaxLogSize {
        $obj = $Xml.Configuration.Client | Where-Object {$_.Name -like 'Log'} | Select-Object -ExpandProperty 'MaxLogSize'
        Write-Output $obj
    }

    Function Get-XMLConfigClientMaxLogHistory {
        $obj = $Xml.Configuration.Client | Where-Object {$_.Name -like 'Log'} | Select-Object -ExpandProperty 'MaxLogHistory'
        Write-Output $obj
    }

    Function Get-XMLConfigClientMaxLogSizeEnabled {
        $obj = $Xml.Configuration.Client | Where-Object {$_.Name -like 'Log'} | Select-Object -ExpandProperty 'Enable'
        Write-Output $obj
    }

    Function Get-XMLConfigClientCache {
        $obj = $Xml.Configuration.Client | Where-Object {$_.Name -like 'CacheSize'} | Select-Object -ExpandProperty 'Value'
        Write-Output $obj
    }

    Function Get-XMLConfigClientCacheEnable {
        $obj = $Xml.Configuration.Client | Where-Object {$_.Name -like 'CacheSize'} | Select-Object -ExpandProperty 'Enable'
        Write-Output $obj
    }

    Function Get-XMLConfigClientShare {
        $obj = $Xml.Configuration.Client | Where-Object {$_.Name -like 'Share'} | Select-Object -ExpandProperty '#text'
        Write-Output $obj
    }

    Function Get-XMLConfigUpdatesShare {
        $obj = $Xml.Configuration.Option | Where-Object {$_.Name -like 'Updates'} | Select-Object -ExpandProperty 'Share'
        Write-Output $obj
    }

    Function Get-XMLConfigUpdatesEnable {
        $obj = $Xml.Configuration.Option | Where-Object {$_.Name -like 'Updates'} | Select-Object -ExpandProperty 'Enable'
        Write-Output $obj
    }

    Function Get-XMLConfigUpdatesFix {
        $obj = $Xml.Configuration.Option | Where-Object {$_.Name -like 'Updates'} | Select-Object -ExpandProperty 'Fix'
        Write-Output $obj
    }

    Function Get-XMLConfigLoggingShare {
        $obj = $Xml.Configuration.Log | Where-Object {$_.Name -like 'File'} | Select-Object -ExpandProperty 'Share'
        Write-Output $obj
    }

    Function Get-XMLConfigLoggingLocalFile {
        $obj = $Xml.Configuration.Log | Where-Object {$_.Name -like 'File'} | Select-Object -ExpandProperty 'LocalLogFile'
        Write-Output $obj
    }

    Function Get-XMLConfigLoggingEnable {
        $obj = $Xml.Configuration.Log | Where-Object {$_.Name -like 'File'} | Select-Object -ExpandProperty 'Enable'
        Write-Output $obj
    }

    Function Get-XMLConfigLoggingMaxHistory {
        $obj = $Xml.Configuration.Log | Where-Object {$_.Name -like 'File'} | Select-Object -ExpandProperty 'MaxLogHistory'
        Write-Output $obj
    }

    Function Get-XMLConfigLogginLevel {
        $obj = $Xml.Configuration.Log | Where-Object {$_.Name -like 'File'} | Select-Object -ExpandProperty 'Level'
        Write-Output $obj
    }

    Function Get-XMLConfigLoggingTimeFormat {
        $obj = $Xml.Configuration.Log | Where-Object {$_.Name -like 'Time'} | Select-Object -ExpandProperty 'Format'
        Write-Output $obj
    }

    Function Get-XMLConfigPendingRebootApp {
        $obj = $Xml.Configuration.Option | Where-Object {$_.Name -like 'PendingReboot'} | Select-Object -ExpandProperty 'StartRebootApplication'
        Write-Output $obj
    }

    Function Get-XMLConfigMaxRebootDays {
        $obj = $Xml.Configuration.Option | Where-Object {$_.Name -like 'MaxRebootDays'} | Select-Object -ExpandProperty 'Days'
        Write-Output $obj
    }

    Function Get-XMLConfigRebootApplication {
        $obj = $Xml.Configuration.Option | Where-Object {$_.Name -like 'RebootApplication'} | Select-Object -ExpandProperty 'Application'
        Write-Output $obj
    }

    Function Get-XMLConfigRebootApplicationEnable {
        $obj = $Xml.Configuration.Option | Where-Object {$_.Name -like 'RebootApplication'} | Select-Object -ExpandProperty 'Enable'
        Write-Output $obj
    }

    Function Get-XMLConfigDNSCheck {
        $obj = $Xml.Configuration.Option | Where-Object {$_.Name -like 'DNSCheck'} | Select-Object -ExpandProperty 'Enable'
        Write-Output $obj
    }
    
    Function Get-XMLConfigCcmSQLCELog {
        $obj = $Xml.Configuration.Option | Where-Object {$_.Name -like 'CcmSQLCELog'} | Select-Object -ExpandProperty 'Enable'
        Write-Output $obj
    }

    Function Get-XMLConfigDNSFix {
        $obj = $Xml.Configuration.Option | Where-Object {$_.Name -like 'DNSCheck'} | Select-Object -ExpandProperty 'Fix'
        Write-Output $obj
    }

    Function Get-XMLConfigDrivers {
        $obj = $Xml.Configuration.Option | Where-Object {$_.Name -like 'Drivers'} | Select-Object -ExpandProperty 'Enable'
        Write-Output $obj
    }

    Function Get-XMLConfigPatchLevel {
        $obj = $Xml.Configuration.Option | Where-Object {$_.Name -like 'PatchLevel'} | Select-Object -ExpandProperty 'Enable'
        Write-Output $obj
    }

    Function Get-XMLConfigOSDiskFreeSpace {
        $obj = $Xml.Configuration.Option | Where-Object {$_.Name -like 'OSDiskFreeSpace'} | Select-Object -ExpandProperty '#text'
        Write-Output $obj
    }

    Function Get-XMLConfigHardwareInventoryEnable {
        $obj = $Xml.Configuration.Option | Where-Object {$_.Name -like 'HardwareInventory'} | Select-Object -ExpandProperty 'Enable'
        Write-Output $obj
    }

    Function Get-XMLConfigHardwareInventoryFix {
        $obj = $Xml.Configuration.Option | Where-Object {$_.Name -like 'HardwareInventory'} | Select-Object -ExpandProperty 'Fix'
        Write-Output $obj
    }

    Function Get-XMLConfigSoftwareMeteringEnable {
        $obj = $Xml.Configuration.Option | Where-Object {$_.Name -like 'SoftwareMetering'} | Select-Object -ExpandProperty 'Enable'
        Write-Output $obj
    }

    Function Get-XMLConfigSoftwareMeteringFix {
        $obj = $Xml.Configuration.Option | Where-Object {$_.Name -like 'SoftwareMetering'} | Select-Object -ExpandProperty 'Fix'
        Write-Output $obj
    }

    Function Get-XMLConfigHardwareInventoryDays {
        $obj = $Xml.Configuration.Option | Where-Object {$_.Name -like 'HardwareInventory'} | Select-Object -ExpandProperty 'Days'
        Write-Output $obj
    }

    Function Get-XMLConfigRemediationAdminShare {
        $obj = $Xml.Configuration.Remediation | Where-Object {$_.Name -like 'AdminShare'} | Select-Object -ExpandProperty 'Fix'
        Write-Output $obj
    }

    Function Get-XMLConfigRemediationClientProvisioningMode {
        $obj = $Xml.Configuration.Remediation | Where-Object {$_.Name -like 'ClientProvisioningMode'} | Select-Object -ExpandProperty 'Fix'
        Write-Output $obj
    }

    Function Get-XMLConfigRemediationClientStateMessages {
        $obj = $Xml.Configuration.Remediation | Where-Object {$_.Name -like 'ClientStateMessages'} | Select-Object -ExpandProperty 'Fix'
        Write-Output $obj
    }

    Function Get-XMLConfigRemediationClientWUAHandler {
        $obj = $Xml.Configuration.Remediation | Where-Object {$_.Name -like 'ClientWUAHandler'} | Select-Object -ExpandProperty 'Fix'
        Write-Output $obj
    }

    Function Get-XMLConfigBITSCheck {
        $obj = $Xml.Configuration.Option | Where-Object {$_.Name -like 'BITSCheck'} | Select-Object -ExpandProperty 'Enable'
        Write-Output $obj
    }

    Function Get-XMLConfigBITSCheckFix {
        $obj = $Xml.Configuration.Option | Where-Object {$_.Name -like 'BITSCheck'} | Select-Object -ExpandProperty 'Fix'
        Write-Output $obj
    }

    Function Get-XMLConfigWMI {
        $obj = $Xml.Configuration.Option | Where-Object {$_.Name -like 'WMI'} | Select-Object -ExpandProperty 'Enable'
        Write-Output $obj
    }

    Function Get-XMLConfigWMIRepairEnable {
        $obj = $Xml.Configuration.Option | Where-Object {$_.Name -like 'WMI'} | Select-Object -ExpandProperty 'Fix'
        Write-Output $obj
    }

    Function Get-XMLConfigRemediationClientCertificate {
        $obj = $Xml.Configuration.Remediation | Where-Object {$_.Name -like 'ClientCertificate'} | Select-Object -ExpandProperty 'Fix'
        Write-Output $obj
    }

    Function Get-XMLConfigSQLServer {
        $obj = $Xml.Configuration.Log | Where-Object {$_.Name -like 'SQL'} | Select-Object -ExpandProperty 'Server'
        Write-Output $obj
    }

    Function Get-XMLConfigSQLLoggingEnable {
        $obj = $Xml.Configuration.Log | Where-Object {$_.Name -like 'SQL'} | Select-Object -ExpandProperty 'Enable'
        Write-Output $obj
    }



    # End Getters - XML config file

    Function GetComputerInfo {
        $info = Get-Info | Select-Object HostName, OperatingSystem, Architecture, Build, InstallDate, Manufacturer, Model, LastLoggedOnUser
        #$text = 'Computer info'+ "`n"
        $text = 'Hostname: ' +$info.HostName
        Write-Output $text
        #Out-LogFile -Xml $xml $text
        $text = 'Operatingsystem: ' +$info.OperatingSystem
        Write-Output $text
        #Out-LogFile -Xml $xml $text
        $text = 'Architecture: ' + $info.Architecture
        Write-Output $text
        #Out-LogFile -Xml $xml $text
        $text = 'Build: ' + $info.Build
        Write-Output $text
        #Out-LogFile -Xml $xml $text
        $text = 'Manufacturer: ' + $info.Manufacturer
        Write-Output $text
        #Out-LogFile -Xml $xml $text
        $text = 'Model: ' + $info.Model
        Write-Output $text
        #Out-LogFile -Xml $xml $text
        $text = 'InstallDate: ' + $info.InstallDate
        Write-Output $text
        #Out-LogFile -Xml $xml $text
        $text = 'LastLoggedOnUser: ' + $info.LastLoggedOnUser
        Write-Output $text
        #Out-LogFile -Xml $xml $text
    }

    Function Test-ConfigMgrHealthLogging {
        # Verifies that logfiles are not bigger than max history

        $localLogging = (Get-XMLConfigLoggingLocalFile).ToLower()
        if ($localLogging -eq "true") {
            $clientpath = Get-LocalFilesPath
            $logfile = "$clientpath\ClientHealth.log"
            Test-LogFileHistory -Logfile $logfile
        }

        $fileshareLogging = (Get-XMLConfigLoggingEnable).ToLower()
        if ($fileshareLogging -eq "true") {
            $logfile = Get-LogFileName
            Test-LogFileHistory -Logfile $logfile
        }
    }
   
    Function CleanUp {
        $clientpath = Get-LocalFilesPath
        
        if ((Test-Path "$clientpath\Temp" -ErrorAction SilentlyContinue) -eq $True) {
            Write-Verbose "Cleaning up temporary files in $clientpath\ClientHealth"
            Remove-Item "$pclientpathath\Temp" -Recurse -Force | Out-Null
        }
        
        $LocalLogging = ((Get-XMLConfigLoggingLocalFile).ToString()).ToLower()
        if ($LocalLogging -ne "true") {
            Write-Verbose "Local logging disabled. Removing $clientpath\ClientHealth"
            Remove-Item "$clientpath\Temp" -Recurse -Force | Out-Null
        }
    }

    Function New-LogObject {
        Write-Verbose "Start New-LogObject"

        $OS = Get-WmiObject -class Win32_OperatingSystem
        $CS = Get-WmiObject -class Win32_ComputerSystem

        if ($CS.Manufacturer -like 'Lenovo') {
            $Model = (Get-WmiObject Win32_ComputerSystemProduct).Version
        }
        else {
            $Model = $CS.Model
        }
        
        # Handles different OS languages
        $Hostname = Get-Computername
        $OperatingSystem = $OS.Caption
        $Architecture = ($OS.OSArchitecture -replace ('([^0-9])(\.*)', '')) + '-Bit'
        $Build = (Get-ItemProperty -Path 'HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion').BuildLabEx
        $Manufacturer = $CS.Manufacturer
        $Model = $Model
        $ClientVersion = 'Unknown'
        $Sitecode = Get-Sitecode
        $Domain = Get-Domain
        $MaxLogSize = 0
        $MaxLogHistory = 0
        $InstallDate = Get-SmallDateTime -Date ($OS.ConvertToDateTime($OS.InstallDate))
        $InstallDate = $InstallDate -replace '\.', ':'
        $LastLoggedOnUser = (Get-ItemProperty -Path 'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Authentication\LogonUI\').LastLoggedOnUser
        $CacheSize = Get-ClientCache
        $Services = 'Unknown'
        $Updates = 'Unknown'
        $DNS = 'Unknown'
        $Drivers = 'Unknown'
        $Certificate = 'Unknown'
        $PendingReboot = 'Unknown'
        $RebootApp = 'Unknown'
        $LastBootTime = Get-SmallDateTime -Date ($OS.ConvertToDateTime($OS.LastBootUpTime))
        $LastBootTime = $LastBootTime -replace '\.', ':'
        $OSDiskFreeSpace = Get-OSDiskFreeSpace
        $AdminShare = 'Unknown'
        $ProvisioningMode = 'Unknown'
        $StateMessages = 'Unknown'
        $WUAHandler = 'Unknown'
        $WMI = 'Unknown'
        $Updates = 'Unknown'
        $Services = 'Unknown'
        $smallDateTime = Get-SmallDateTime
        $smallDateTime = $smallDateTime -replace '\.', ':'
        [float]$PSVersion = [float]$psVersion = [float]$PSVersionTable.PSVersion.Major + ([float]$PSVersionTable.PSVersion.Minor / 10)
        [int]$PSBuild = [int]$PSVersionTable.PSVersion.Build
        if ($PSBuild -le 0) {
            $PSBuild = $null
        }
        $UBR = Get-UBR
        $BITS = $null

        $obj = New-Object PSObject -Property @{
            Hostname = $Hostname
            Operatingsystem = $OperatingSystem
            Architecture = $Architecture
            Build = $Build
            Manufacturer = $Manufacturer
            Model = $Model
            InstallDate = $InstallDate 
            LastLoggedOnUser = $LastLoggedOnUser
            ClientVersion = $ClientVersion
            Sitecode = $Sitecode
            Domain = $Domain
            MaxLogSize = $MaxLogSize
            MaxLogHistory = $MaxLogHistory
            CacheSize = $CacheSize
            Certificate = $Certificate
            ProvisioningMode = $ProvisioningMode
            DNS = $DNS
            Drivers = $Drivers
            Updates = $Updates
            PendingReboot = $PendingReboot
            RebootApp = $RebootApp
            LastBootTime = $LastBootTime
            OSDiskFreeSpace = $OSDiskFreeSpace
            AdminShare = $AdminShare
            StateMessages = $StateMessages
            WUAHandler = $WUAHandler
            WMI = $WMI
            Timestamp = $smallDateTime
            Version = $Version
            Services = $Services
            PSVersion = $PSVersion
            PSBuild = $PSBuild
            OSUpdates = $null
            HWInventory = $null
            ClientInstalled = $null
            SWMetering = $null
            PatchLevel = $UBR
            BITS = $BITS
            ClientInstalledReason = $null
        }
        Write-Output $obj
        Write-Verbose "End New-LogObject"
    }

    Function Get-SmallDateTime {
        Param([Parameter(Mandatory=$false)]$Date)
        Write-Verbose "Start Get-SmallDateTime"

        $UTC = (Get-XMLConfigLoggingTimeFormat).ToLower()

        if ($null -ne $Date) {
            if ($UTC -eq "utc") {
                $obj = (Get-UTCTime -DateTime $Date).ToString("yyyy-MM-dd HH:mm:ss")
            }
            else {
                $obj = ($Date).ToString("yyyy-MM-dd HH:mm:ss")
            }
        }

        else { $obj = Get-DateTime }

        <#
        if ($null -ne $Date) {
            $obj = ($Date).ToString("yyyy-MM-dd HH:mm:ss")
        }
        else {
            $obj = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
        }
        #>
        $obj = $obj -replace '\.', ':'
        Write-Output $obj
        Write-Verbose "End Get-SmallDateTime"
    }

    # Test some values are whole numbers before attempting to insert / update database
    Function Test-ValuesBeforeLogUpdate {
        Write-Verbose "Start Test-ValuesBeforeLogUpdate"
        $Log.MaxLogSize = [Math]::Round($Log.MaxLogSize)
        $Log.MaxLogHistory = [Math]::Round($Log.MaxLogHistory)
        $Log.PSBuild = [Math]::Round($Log.PSBuild)
        $Log.CacheSize = [Math]::Round($Log.CacheSize)
        Write-Verbose "End Test-ValuesBeforeLogUpdate"
    }

    Function Update-SQL {
        Param(
            [Parameter(Mandatory=$true)]$Log,
            [Parameter(Mandatory=$false)]$Table
        )

        Write-Verbose "Start Update-SQL"
        Test-ValuesBeforeLogUpdate

        $SQLServer = Get-XMLConfigSQLServer
        $Database = 'ClientHealth'
        $table = 'dbo.Clients'
        $smallDateTime = Get-SmallDateTime
        
        if ($null -ne $log.OSUpdates) {
            # UPDATE
            $q1 = "OSUpdates='"+$log.OSUpdates+"', "
            # INSERT INTO
            $q2 = "OSUpdates, "
            # VALUES
            $q3 = "'"+$log.OSUpdates+"', "
        }
        else {
            $q1 = $null
            $q2 = $null
            $q3 = $null
        }

        if ($null -ne $log.ClientInstalled) {
            # UPDATE
            $q10 = "ClientInstalled='"+$log.ClientInstalled+"', "
            # INSERT INTO
            $q20 = "ClientInstalled, "
            # VALUES
            $q30 = "'"+$log.ClientInstalled+"', "
        }
        else {
            $q10 = $null
            $q20 = $null
            $q30 = $null
        }
        
        $query= "begin tran
        if exists (SELECT * FROM $table WITH (updlock,serializable) WHERE Hostname='"+$log.Hostname+"')
        begin
            UPDATE $table SET Operatingsystem='"+$log.Operatingsystem+"', Architecture='"+$log.Architecture+"', Build='"+$log.Build+"', Manufacturer='"+$log.Manufacturer+"', Model='"+$log.Model+"', InstallDate='"+$log.InstallDate+"', $q1 LastLoggedOnUser='"+$log.LastLoggedOnUser+"', ClientVersion='"+$log.ClientVersion+"', PSVersion='"+$log.PSVersion+"', PSBuild='"+$log.PSBuild+"', Sitecode='"+$log.Sitecode+"', Domain='"+$log.Domain+"', MaxLogSize='"+$log.MaxLogSize+"', MaxLogHistory='"+$log.MaxLogHistory+"', CacheSize='"+$log.CacheSize+"', ClientCertificate='"+$log.Certificate+"', ProvisioningMode='"+$log.ProvisioningMode+"', DNS='"+$log.DNS+"', Drivers='"+$log.Drivers+"', Updates='"+$log.Updates+"', PendingReboot='"+$log.PendingReboot+"', LastBootTime='"+$log.LastBootTime+"', OSDiskFreeSpace='"+$log.OSDiskFreeSpace+"', Services='"+$log.Services+"', AdminShare='"+$log.AdminShare+"', StateMessages='"+$log.StateMessages+"', WUAHandler='"+$log.WUAHandler+"', WMI='"+$log.WMI+"', HWInventory='"+$log.HWInventory+"', Version='"+$Version+"', $q10 Timestamp='"+$smallDateTime+"', SWMetering='"+$log.SWMetering+"', BITS='"+$log.BITS+"', PatchLevel='"+$Log.PatchLevel+"', ClientInstalledReason='"+$log.ClientInstalledReason+"'
            WHERE Hostname = '"+$log.Hostname+"'
        end
        else
        begin
            INSERT INTO $table (Hostname, Operatingsystem, Architecture, Build, Manufacturer, Model, InstallDate, $q2 LastLoggedOnUser, ClientVersion, PSVersion, PSBuild, Sitecode, Domain, MaxLogSize, MaxLogHistory, CacheSize, ClientCertificate, ProvisioningMode, DNS, Drivers, Updates, PendingReboot, LastBootTime, OSDiskFreeSpace, Services, AdminShare, StateMessages, WUAHandler, WMI, HWInventory, Version, $q20 Timestamp, SWMetering, BITS, PatchLevel, ClientInstalledReason)
            VALUES ('"+$log.Hostname+"', '"+$log.Operatingsystem+"', '"+$log.Architecture+"', '"+$log.Build+"', '"+$log.Manufacturer+"', '"+$log.Model+"', '"+$log.InstallDate+"', $q3 '"+$log.LastLoggedOnUser+"', '"+$log.ClientVersion+"', '"+$log.PSVersion+"', '"+$log.PSBuild+"', '"+$log.Sitecode+"', '"+$log.Domain+"', '"+$log.MaxLogSize+"', '"+$log.MaxLogHistory+"', '"+$log.CacheSize+"', '"+$log.Certificate+"', '"+$log.ProvisioningMode+"', '"+$log.DNS+"', '"+$log.Drivers+"', '"+$log.Updates+"', '"+$log.PendingReboot+"', '"+$log.LastBootTime+"', '"+$log.OSDiskFreeSpace+"', '"+$log.Services+"', '"+$log.AdminShare+"', '"+$log.StateMessages+"', '"+$log.WUAHandler+"', '"+$log.WMI+"', '"+$log.HWInventory+"', '"+$log.Version+"', $q30 '"+$smallDateTime+"', '"+$log.SWMetering+"', '"+$log.BITS+"', '"+$Log.PatchLevel+"', '"+$Log.ClientInstalledReason+"')
        end
        commit tran"

        try {
            Invoke-SqlCmd2 -ServerInstance $SQLServer -Database $Database -Query $query
        } catch {
            $ErrorMessage = $_.Exception.Message
            $text = "Error updating SQL with the following query: $transactSQL. Error: $ErrorMessage"
            Write-Error $text
            Out-LogFile -Xml $Xml -Text "ERROR Insert/Update SQL. SQL Query: $query `nSQL Error: $ErrorMessage"
        }

        Write-Verbose "End Update-SQL"
    }
        
    Function Update-LogFile {
        Param(
            [Parameter(Mandatory=$true)]$Log,
            [Parameter(Mandatory=$false)]$Mode
            )
        # Start the logfile
        Write-Verbose "Start Update-LogFile"
        #$share = Get-XMLConfigLoggingShare

        Test-ValuesBeforeLogUpdate
        $logfile = $logfile = Get-LogFileName
        Test-LogFileHistory -Logfile $logfile
        $text = "<--- ConfigMgr Client Health Check starting --->"
        $text += $log | Select-Object Hostname, Operatingsystem, Architecture, Build, Model, InstallDate, OSUpdates, LastLoggedOnUser, ClientVersion, PSVersion, PSBuild, SiteCode, Domain, MaxLogSize, MaxLogHistory, CacheSize, Certificate, ProvisioningMode, DNS, PendingReboot, LastBootTime, OSDiskFreeSpace, Services, AdminShare, StateMessages, WUAHandler, WMI, ClientInstalled, Version, Timestamp, HWInventory, SWMetering, BITS, PatchLevel, ClientInstalledReason | Out-String
        $text = $text.replace("`t","")
        $text = $text.replace("  ","")
        $text = $text.replace(" :",":")
        $text = $text -creplace '(?m)^\s*\r?\n',''
        
        if ($Mode -eq 'Local') { Out-LogFile -Xml $xml -Text $text -Mode $Mode }
        elseif ($Mode -eq 'ClientInstalledFailed') { Out-LogFile -Xml $xml -Text $text -Mode $Mode }
        else { Out-LogFile -Xml $xml -Text $text }
        Write-Verbose "End Update-LogFile"
    }
    
    #endregion
    
    # Set default restart values to false
    $newinstall = $false
    $restartCCMExec = $false
    $Reinstall = $false

    # Build the ConfigMgr Client Install Property string
    $propertyString = ""

    foreach ($property in $Xml.Configuration.ClientInstallProperty) {
        $propertyString = $propertyString + $property
        $propertyString = $propertyString + ' '
    }
    $clientCacheSize = Get-XMLConfigClientCache
    $clientInstallProperties = $propertyString + "SMSCACHESIZE=$clientCacheSize"
    $clientAutoUpgrade = (Get-XMLConfigClientAutoUpgrade).ToLower()
    $AdminShare = Get-XMLConfigRemediationAdminShare
    $ClientProvisioningMode = Get-XMLConfigRemediationClientProvisioningMode
    $ClientStateMessages = Get-XMLConfigRemediationClientStateMessages
    $ClientWUAHandler = Get-XMLConfigRemediationClientWUAHandler
    $LogShare = Get-XMLConfigLoggingShare

    # Create a DataTable to store all changes to log files to be processed later. This to prevent false positives to remediate the next time script runs if error is already remediated.
    $SCCMLogJobs = New-Object System.Data.DataTable
    [Void]$SCCMLogJobs.Columns.Add("File")
    [Void]$SCCMLogJobs.Columns.Add("Text")

}

Process {
    Write-Verbose "Start Process"
    # Veriy script is running with administrative priveleges.
    If (-NOT ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator"))
    {
        $text = 'ERROR: Powershell not running as Administrator!'
        Out-LogFile -Xml $Xml -Text $text
        Write-Error $text
        Exit 1
    }

    $LocalLogging = ((Get-XMLConfigLoggingLocalFile).ToString()).ToLower()
    $FileLogging = ((Get-XMLConfigLoggingEnable).ToString()).ToLower()
    $FileLogLevel = ((Get-XMLConfigLogginLevel).ToString()).ToLower()
    $SQLLogging = ((Get-XMLConfigSQLLoggingEnable).ToString()).ToLower()

    Write-Verbose "Testing if log files are bigger than max history for logfiles."
    Test-ConfigMgrHealthLogging

    # Create the log object containing the result of health check
    $Log = New-LogObject

    Write-Verbose 'Testing SQL Server connection'
    if (($SQLLogging -like 'true') -and ((Test-SQLConnection) -eq $false)) {
        # Failed to create SQL connection. Logging this error to fileshare and aborting script.
        #Exit 1
    }
    
    Write-Verbose 'Validating WMI is not corrupt...'
    $WMI = Get-XMLConfigWMI
    if ($WMI -like 'True') {
        Write-Verbose 'Checking if WMI is corrupt. Will reinstall configmgr client if WMI is rebuilt.'
        if ((Test-WMI -log $Log) -eq $true) {
            $reinstall = $true
            New-ClientInstalledReason -Log $Log -Message "Corrupt WMI."
        }
    }

    Write-Verbose 'Testing if ConfigMgr client is installed. Installing if not.'
    Test-ConfigMgrClient -Log $Log

    Write-Verbose 'Validating if ConfigMgr client is running the minimum version...'
    if ((Test-ClientVersion -Log $log) -eq $true) {
        if ($clientAutoUpgrade -like 'true') {
            $reinstall = $true
            New-ClientInstalledReason -Log $Log -Message "Below minimum verison."
        }
    }

    <#
    Write-Verbose 'Validate that ConfigMgr client do not have CcmSQLCE.log and are not in debug mode'
    if (Test-CcmSQLCELog -eq $true) {
        # This is a very bad situation. ConfigMgr agent is fubar. Local SDF files are deleted by the test itself, now reinstalling client immediatly. Waiting 10 minutes before continuing with health check.
        Resolve-Client -Xml $xml -ClientInstallProperties $ClientInstallProperties
        Start-Sleep -Seconds 600
    }
    #>

    Write-Verbose 'Validating services...'
    Test-Services -Xml $Xml -log $log

    # Enforce ConfigMgr agent is running
    $ccmservice = Get-Service -Name CcmExec -ErrorAction SilentlyContinue
    if ($ccmservice.Status -ne 'Running') {
        try {
            Start-Service -Name CcmExec
            Start-Sleep -Seconds 2
        }
        catch {}
    }

    Write-Verbose 'Validating ConfigMgr SiteCode...'
    if ((Test-ClientSiteCode -Log $Log) -eq $true) {
        $reinstall = $true
        New-ClientInstalledReason -Log $Log -Message "Wrong sitecode."
    }

    Write-Verbose 'Validating client cache size. Will restart configmgr client if cache size is changed'    
    
    $CacheCheckEnabled = Get-XMLConfigClientCacheEnable
    if ($CacheCheckEnabled -like 'True') {
        $TestClientCacheSzie = Test-ClientCacheSize -Log $Log
        if ($TestClientCacheSzie -eq $true) {
            $restartCCMExec = $true
        }
    }

    if ((Get-XMLConfigClientMaxLogSizeEnabled -like 'True') -eq $true) {
        Write-Verbose 'Validating Max CCMClient Log Size...'
        $TestClientLogSize = Test-ClientLogSize -Log $Log
        if ($TestClientLogSize -eq $true) {
            $restartCCMExec = $true
        }
    }

    Write-Verbose 'Validating CCMClient provisioning mode...'
    if (($ClientProvisioningMode -like 'True') -eq $true) {Test-ProvisioningMode -log $log}
    Write-Verbose 'Validating CCMClient certificate...'

    if ((Get-XMLConfigRemediationClientCertificate -like 'True') -eq $true) {Test-CCMCertificateError}
    if (Get-XMLConfigHardwareInventoryEnable -like 'True') {Test-SCCMHardwareInventoryScan -Log $log}

    
    if (Get-XMLConfigSoftwareMeteringEnable -like 'True') {
        Write-Verbose "Testing software metering prep driver check"
        if ((Test-SoftwareMeteringPrepDriver -Log $Log) -eq $false) {$restartCCMExec = $true}
    }
   
    Write-Verbose 'Validating DNS...'
    if ((Get-XMLConfigDNSCheck -like 'True' ) -eq $true) {Test-DNSConfiguration -Log $log}

    Write-Verbose 'Validating BITS'
    if (Get-XMLConfigBITSCheck -like 'True') {
        if ((Test-BITS -Log $Log) -eq $true) {
            #$Reinstall = $true
        }
    } 

    Write-Verbose 'Validating Windows Update Scan not broken by bad group policy...'
    if (($ClientWUAHandler -like 'True') -eq $true) {Test-RegistryPol -log $log}

    Write-Verbose 'Validating that CCMClient is sending state messages...'
    if (($ClientStateMessages -like 'True') -eq $true) {Test-UpdateStore -log $log}

    Write-Verbose 'Validating Admin$ and C$ are shared...'
    if (($AdminShare -like 'True') -eq $true) {Test-AdminShare -log $log}

    Write-Verbose 'Testing that all devices have functional drivers.'
    if ((Get-XMLConfigDrivers -like 'True') -eq $true) {Test-MissingDrivers -Log $log}

    Write-Verbose 'Validating required updates are installed...'
    Test-Update -Log $log
    Write-Verbose 'Validating C: free diskspace (Only warning, no remediation)...'
    Test-DiskSpace
    Write-Verbose 'Getting install date of last OS patch for SQL log'
    Get-LastInstalledPatches -Log $log
    Write-Verbose 'Sending unsent state messages if any'
    Get-SCCMPolicySendUnsentStateMessages
    Write-Verbose 'Getting Source Update Message policy and policy to trigger scan update source'

    if ($newinstall -eq $false) {
        Get-SCCMPolicySourceUpdateMessage
        Get-SCCMPolicyScanUpdateSource
        Get-SCCMPolicySendUnsentStateMessages
    }
    Get-SCCMPolicyMachineEvaluation

    # Restart ConfigMgr client if tagged for restart and no reinstall tag
    if (($restartCCMExec -eq $true) -and ($Reinstall -eq $false)) {
        Write-Output "Restarting service CcmExec..."
    
        if ($SCCMLogJobs.Rows.Count -ge 1) {
            Stop-Service -Name CcmExec
            Write-Verbose "Processing changes to SCCM logfiles after remediation to prevent remediation again next time script runs."
            Update-SCCMLogFile
            Start-Service -Name CcmExec
        }
        else {Restart-Service -Name CcmExec}
        
        $Log.MaxLogSize = Get-ClientMaxLogSize
        $Log.MaxLogHistory = Get-ClientMaxLogHistory
        $log.CacheSize = Get-ClientCache
    }

    # Updating SQL Log object with current version number
    $log.Version = $Version

    Write-Verbose 'Cleaning up after healthcheck'
    CleanUp
    Write-Verbose 'Validating pending reboot...'
    Test-PendingReboot -log $log
    Write-Verbose 'Getting last reboot time'
    Get-LastReboot -Xml $xml

    # Reinstall client if tagged for reinstall and configmgr client is not already installing
    $proc = Get-Process ccmsetup -ErrorAction SilentlyContinue

    if (($reinstall -eq $true) -and ($null -ne $proc) ) {
        Write-Warning "ConfigMgr Client set to reinstall, but ccmsetup.exe is already running."
    }
    elseif (($Reinstall -eq $true) -and ($null -eq $proc)) {
        Write-Verbose 'Reinstalling ConfigMgr Client'
        Resolve-Client -Xml $Xml -ClientInstallProperties $ClientInstallProperties
        # Add smalldate timestamp in SQL for when client was installed by Client Health.
        $log.ClientInstalled = Get-SmallDateTime
        $Log.MaxLogSize = Get-ClientMaxLogSize
        $Log.MaxLogHistory = Get-ClientMaxLogHistory
        $log.CacheSize = Get-ClientCache
    }

    # Trigger default Microsoft CM client health evaluation
    Start-Ccmeval
    Write-Verbose "End Process"
}

End {
    Write-Verbose "Start End"
    # Update database and logfile with results

    if ($LocalLogging -like 'true') {
        Write-Output 'Updating local logfile with results' 
        Update-LogFile -Log $log -Mode 'Local'
    }

    if ($SQLLogging -like 'true') {
        Write-Output 'Updating SQL database with results' 
        Update-SQL -Log $log
    }

    if (($FileLogging -like 'true') -and ($FileLogLevel -like 'full')) {
        Write-Output 'Updating logfile on fileshare with results' 
        Update-LogFile -Log $log
    }
    Write-Verbose "Stop End"
    Write-Verbose "Client Health script finished"
}
